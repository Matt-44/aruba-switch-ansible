diff --git a/ansible/config/base.yml b/ansible/config/base.yml
index 1929d81..8031e92 100644
--- a/ansible/config/base.yml
+++ b/ansible/config/base.yml
@@ -1413,7 +1413,7 @@ MERGE_MULTIPLE_CLI_TAGS:
   version_added: "2.3"
 NETWORK_GROUP_MODULES:
   name: Network module families
-  default: [eos, nxos, ios, iosxr, junos, enos, ce, vyos, sros, dellos9, dellos10, dellos6, asa, aruba, aireos, bigip, ironware, onyx]
+  default: [eos, nxos, ios, iosxr, junos, enos, ce, vyos, sros, dellos9, dellos10, dellos6, asa, aruba, aireos, bigip, ironware, onyx, arubaoss]
   description: 'TODO: write it'
   env: [{name: NETWORK_GROUP_MODULES}]
   ini:
diff --git a/ansible/module_utils/network/arubaoss/__init__.py b/ansible/module_utils/network/arubaoss/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/ansible/module_utils/network/arubaoss/arubaoss.py b/ansible/module_utils/network/arubaoss/arubaoss.py
new file mode 100644
index 0000000..ed72c49
--- /dev/null
+++ b/ansible/module_utils/network/arubaoss/arubaoss.py
@@ -0,0 +1,283 @@
+# This code is part of Ansible, but is an independent component.
+# This particular file snippet, and this file snippet only, is BSD licensed.
+# Modules you write using this snippet, which is embedded dynamically by Ansible
+# still belong to the author of the module, and may assign their own license
+# to the complete work.
+#
+# (c) 2018 Red Hat Inc.
+#
+# Redistribution and use in source and binary forms, with or without modification,
+# are permitted provided that the following conditions are met:
+#
+#    * Redistributions of source code must retain the above copyright
+#      notice, this list of conditions and the following disclaimer.
+#    * Redistributions in binary form must reproduce the above copyright notice,
+#      this list of conditions and the following disclaimer in the documentation
+#      and/or other materials provided with the distribution.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
+# ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
+# WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+# IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
+# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
+# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
+# USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+#
+
+import re
+
+from ansible.module_utils._text import to_text
+from ansible.module_utils.basic import env_fallback, return_values
+from ansible.module_utils.network.common.utils import to_list, ComplexList
+from ansible.module_utils.connection import exec_command
+from ansible.module_utils.six import iteritems
+from ansible.module_utils.urls import fetch_url
+from time import sleep
+
+_DEVICE_CONNECTION = None
+
+arubaoss_provider_spec = {
+    'host': dict(),
+    'port': dict(type='int'),
+    'username': dict(fallback=(env_fallback, ['ANSIBLE_NET_USERNAME'])),
+    'password': dict(fallback=(env_fallback, ['ANSIBLE_NET_PASSWORD']), no_log=True),
+    'ssh_keyfile': dict(fallback=(env_fallback, ['ANSIBLE_NET_SSH_KEYFILE']), type='path'),
+    'use_ssl': dict(type='bool'),
+    'use_proxy': dict(default=False, type='bool'),
+    'validate_certs': dict(default=False, type='bool'),
+    'transport': dict(default='aossapi'),
+    'timeout': dict(type='int'),
+    'validate_certs': dict(type='bool',default=False),
+    'api_version': dict(type='str',default='v5.0'),
+}
+arubaoss_argument_spec = {
+    'provider': dict(type='dict', options=arubaoss_provider_spec)
+}
+
+arubaoss_top_spec = {
+    'host': dict(removed_in_version=2.9),
+    'port': dict(removed_in_version=2.9, type='int'),
+    'username': dict(removed_in_version=2.9),
+    'password': dict(removed_in_version=2.9, no_log=True),
+    'ssh_keyfile': dict(removed_in_version=2.9, type='path'),
+    'timeout': dict(removed_in_version=2.9, type='int'),
+    'use_ssl': dict(type='bool'),
+    'validate_certs': dict(type='bool',default=False),
+    'api_version': dict(type='str',default='v5.0'),
+}
+
+arubaoss_argument_spec.update(arubaoss_top_spec)
+
+
+def get_provider_argspec():
+    return arubaoss_provider_spec
+
+
+def check_args(module, warnings):
+    pass
+
+
+def load_params(module):
+    provider = module.params.get('provider') or dict()
+    for key, value in iteritems(provider):
+        if key in arubaoss_argument_spec:
+            if module.params.get(key) is None and value is not None:
+                module.params[key] = value
+
+
+def get_connection(module):
+    global _DEVICE_CONNECTION
+    if not _DEVICE_CONNECTION:
+        load_params(module)
+        conn = Aossapi(module)
+        _DEVICE_CONNECTION = conn
+    return _DEVICE_CONNECTION
+
+
+class Aossapi:
+    '''
+    This create instance for arubaoss api. The supported version of
+    api is v5.0. Previous version can be used to configure but does
+    not gurantee module will work as intended or may have failure
+    in cases.
+    '''
+
+    def __init__(self, module):
+        self._module = module
+        self._cookie = None
+
+        host = self._module.params['host']
+        port = self._module.params['port']
+
+        if self._module.params['use_ssl']:
+            proto = 'https'
+            port = port or 443
+        else:
+            proto = 'http'
+            port = port or 80
+
+        api = self._module.params['api_version']
+
+        self._url = "{}://{}:{}/rest/{}".format(proto,host,port,api)
+
+    def _send(self, url, method='POST', body={}):
+        '''Sends command to device '''
+
+        headers = {'Content-Type': 'application/json'}
+
+        data = self._module.jsonify(body)
+        if self._cookie:
+            headers['Cookie'] = self._cookie
+
+        response, headers = fetch_url(
+            self._module, url, data=body, headers=headers,
+            method=method, use_proxy=False
+        )
+
+        return response, headers
+
+    def login(self):
+        ''' Created login uri and saves cookie'''
+
+        password = self._module.params['password']
+        username = self._module.params['username']
+
+        url = self._url + "/login-sessions"
+        data = {"userName":username ,"password": password}
+        data = self._module.jsonify(data)
+
+        response, headers = self._send(url, body=data)
+
+        if headers['status'] == 201:
+            self._cookie = headers.get('set-cookie')
+        else:
+            self._module.fail_json(**headers)
+
+    def logout(self):
+        ''' Logout from device '''
+
+        url = self._url + "/login-sessions"
+
+        response, headers = self._send(url, body="", method='DELETE')
+        self._cookie = None
+
+        if headers['status'] != 204:
+            self._module.fail_json(**headers)
+
+    def run_commands(self, uri, payload={}, method="POST", check=None,wait_after_send=0):
+
+        '''
+        Validate that the configuration is present on the device. If not then send command
+        to device for processing. Otherwise return data to module.
+        '''
+
+        reboot = None
+        response = None
+        if method == 'reboot':
+            reboot = True
+            method = 'POST'
+
+        try:
+
+            self.login()
+
+            if check:
+                response = self._validate_request(method, payload, check)
+                if response:
+                    self.logout()
+                    # Configuration change not required
+                    return response
+
+            data = self._module.jsonify(payload)
+
+            url = self._url + uri
+
+            response, headers = self._send(url, body=data, method=method)
+            sleep(wait_after_send)
+
+            if not reboot:
+                self.logout()
+
+            if headers['status'] == 204:
+                return {'msg': 'Successful','changed':True}
+
+            try:
+                if response:
+                    data = response.read()
+                    response = self._module.from_json(to_text(data, errors='surrogate_then_replace'))
+                    response['changed'] = True
+                else:
+                    if headers['status'] not in (200, 201, 202, 204):
+                        headers['failed'] = True
+                        return headers
+
+            except ValueError:
+                self._module.fail_json(msg='unable to load response from device', data=data)
+
+            return response
+        except Exception as err:
+            self._module.fail_json(msg='Failed : {}'.format(err),failed=True)
+
+    def get_config(self, uri, check_login=True):
+        ''' Execute a GET operation of device for uri'''
+
+        url = self._url +  uri
+        headers = {'Content-Type': 'application/json'}
+
+        no_login=False
+        if not self._cookie and check_login:
+            no_login=True
+            self.login()
+
+        if check_login:
+            headers['Cookie'] = self._cookie
+
+        response, headers = fetch_url(self._module, url, headers=headers,
+                method='GET', use_proxy=False)
+
+        if no_login:
+            self.logout()
+
+        if headers['status'] == 200:
+            return response.read()
+
+        return None
+
+    def _validate_request(self, method, payload, check):
+        '''Compares value being applied to the configuration present on the device'''
+
+        check_presence = self.get_config(check)
+        if method == 'DELETE':
+            if not check_presence:
+                response = {'changed': False,
+                            'failed': False,
+                            'msg': 'Not present'}
+                return response
+        elif method != 'GET':
+            if check_presence:
+                diffkeys = False
+                data = self._module.from_json(to_text(check_presence))
+                for key in payload:
+                    if key in data:
+                        if payload[key] != data[key]:
+                            diffkeys = True
+                            break
+
+                if not diffkeys:
+                    data['changed'] = False
+                    data['failed'] = False
+                    return data
+
+
+        return None
+
+def get_config(module, *args, **kwargs):
+    conn = get_connection(module)
+    return conn.get_config(*args, **kwargs)
+
+
+def run_commands(module, commands, *args, **kwargs):
+    conn = get_connection(module)
+    return conn.run_commands(commands, *args, **kwargs)
diff --git a/ansible/modules/network/arubaoss/__init__.py b/ansible/modules/network/arubaoss/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/ansible/modules/network/arubaoss/arubaoss_aaa_accounting.py b/ansible/modules/network/arubaoss/arubaoss_aaa_accounting.py
new file mode 100644
index 0000000..169da46
--- /dev/null
+++ b/ansible/modules/network/arubaoss/arubaoss_aaa_accounting.py
@@ -0,0 +1,158 @@
+#!/usr/bin/python
+
+ANSIBLE_METADATA = {
+    'metadata_version': '1.1',
+    'status': ['preview'],
+    'supported_by': 'community'
+}
+
+DOCUMENTATION = '''
+---
+module: arubaoss_aaa_accounting
+
+short_description: implements rest api for AAA Accounting configuration
+
+version_added: "2.4"
+
+description:
+    - "This implements rest apis which can be used to configure AAA Accounting"
+
+options:
+    cmd_accounting_method
+        description: Method for commands Accounting Configuration
+        choices: AME_NONE, AME_TACACS, AME_RADIUS
+        required: False
+    cmd_accounting_mode
+        description: Mode for commands Accounting Configuration
+        choices: AMO_NONE, AMO_STOP_ONLY
+        required: False
+    ntwk_accounting_method
+        description: Method for network Accounting Configuration
+        choices: AME_NONE, AME_TACACS, AME_RADIUS
+        required: False
+    ntwk_accounting_mode
+        description: Mode for network Accounting Configuration
+        choices: AMO_NONE, AMO_STOP_ONLY, AMO_START_STOP
+        required: False
+    update_interval
+        description: Update interval for accounting
+        required: False
+
+author:
+    - Sanju Sadanandan (@hpe)
+'''
+
+EXAMPLES = '''
+     - name: Updates the given accounting configuration to the system
+       arubaoss_aaa_accounting:
+         cmd_accounting_method: "AME_TACACS"
+         cmd_accounting_mode: "AMO_STOP_ONLY"
+         ntwk_accounting_method: "AME_NONE"
+         ntwk_accounting_mode: "AMO_NONE"
+         update_interval: 10
+'''
+
+import json
+from ansible.module_utils.basic import AnsibleModule
+from ansible.module_utils.network.arubaoss.arubaoss import run_commands
+from ansible.module_utils.network.arubaoss.arubaoss import arubaoss_argument_spec
+from ansible.module_utils.network.arubaoss.arubaoss import get_config
+
+"""
+-------
+Name: config_accounting
+
+Configures port with mstp config
+
+param request: module
+
+Returns
+ Configure the switch with params sent
+-------
+"""
+def config_accounting(module):
+
+    params = module.params
+
+    data = {}
+    serverGrp = {}
+    data['update_interval'] =params['update_interval']
+    data['accounting_commands'] = {
+            'accounting_method': params ['cmd_accounting_method'],
+            'accounting_mode': params ['cmd_accounting_mode']}
+
+    # Server Group name is not supported when accounting_method is AME_TACACS
+    if not params['cmd_accounting_method'] == "AME_TACACS":
+        serverGrp = {'server_group': params['cmd_server_group']}
+    else:
+        serverGrp = {'server_group': ""}
+
+    data['accounting_commands'].update(serverGrp)
+
+    data['accounting_network'] = {
+            'accounting_method': params ['ntwk_accounting_method'],
+            'accounting_mode': params ['ntwk_accounting_mode']}
+
+    # Server Group name is not supported when accounting_method is AME_TACACS
+    if not params['ntwk_accounting_method'] == "AME_TACACS":
+        serverGrp = {'server_group': params['cmd_server_group']}
+    else:
+        serverGrp = {'server_group': ""}
+
+    data['accounting_network'].update(serverGrp)
+
+    url = '/accounting'
+    method = 'PUT'
+
+    result = run_commands(module, url, data, method, check=url)
+    return result
+
+"""
+-------
+Name: run_module()
+
+The main module invoked
+
+Returns
+ Configure the switch with params sent
+-------
+"""
+def run_module():
+    module_args = dict(
+        cmd_accounting_method=dict(type='str', required=False, default='AME_NONE',
+               choices = ["AME_NONE", "AME_TACACS", "AME_RADIUS"]),
+        cmd_accounting_mode=dict(type='str', required=False, default='AMO_NONE',
+               choices = ["AMO_NONE", "AMO_STOP_ONLY"]),
+        ntwk_accounting_method=dict(type='str', required=False, default='AME_NONE',
+               choices = ["AME_NONE", "AME_TACACS", "AME_RADIUS"]),
+        ntwk_accounting_mode=dict(type='str', required=False, default='AMO_NONE',
+               choices = ["AMO_NONE", "AMO_STOP_ONLY", "AMO_START_STOP"]),
+        update_interval=dict(type='int', required=False, default='0'),
+        cmd_server_group=dict(type='str', required=False, default=''),
+        ntwk_server_group=dict(type='str', required=False, default=''),
+    )
+
+    module_args.update(arubaoss_argument_spec)
+
+    result = dict(changed=False,warnings='Not Supported')
+
+    module = AnsibleModule(
+        argument_spec=module_args,
+        supports_check_mode=True
+    )
+
+    if module.check_mode:
+        module.exit_json(**result)
+
+    try:
+        result = config_accounting(module)
+    except Exception as err:
+        return module.fail_json(msg=err)
+
+    module.exit_json(**result)
+
+def main():
+    run_module()
+
+if __name__ == '__main__':
+    main()
diff --git a/ansible/modules/network/arubaoss/arubaoss_aaa_authentication.py b/ansible/modules/network/arubaoss/arubaoss_aaa_authentication.py
new file mode 100644
index 0000000..74ad25c
--- /dev/null
+++ b/ansible/modules/network/arubaoss/arubaoss_aaa_authentication.py
@@ -0,0 +1,184 @@
+#!/usr/bin/python
+
+ANSIBLE_METADATA = {
+    'metadata_version': '1.1',
+    'status': ['preview'],
+    'supported_by': 'community'
+}
+
+DOCUMENTATION = '''
+---
+module: arubaoss_aaa_authentication
+
+short_description: implements rest api for AAA Authentication configuration
+
+version_added: "2.4"
+
+description:
+    - "This implements rest apis which can be used to configure authentication"
+
+options:
+    command:
+        description: Function name calls according to configuration required
+        choices: config_authentication, config_authentication_console, config_authentication_ssh
+        required: False
+    is_privilege_mode_enabled:
+        description: To enable/disable privilaged mode
+        required: False
+    primary_method:
+        description: The primary authentication method
+        choices: PAM_LOCAL, PAM_TACACS
+        required: False
+    secondary_method
+        description: The secondary authentication method
+        choices: SAM_NONE, SAM_LOCAL
+        required: False
+
+author:
+    - Sanju Sadanandan (@hpe)
+'''
+
+EXAMPLES = '''
+     - name: Updates the given console authentication configuration to the system
+       arubaoss_aaa_authentication:
+         primary_method: "PAM_TACACS"
+         secondary_method: "SAM_LOCAL"
+         command: config_authentication_console
+'''
+
+
+from ansible.module_utils.basic import AnsibleModule
+from ansible.module_utils.network.arubaoss.arubaoss import run_commands
+from ansible.module_utils.network.arubaoss.arubaoss import arubaoss_argument_spec
+
+"""
+-------
+Name: config_authentication
+
+Configures port with authentication config
+
+param request: module
+
+Returns
+ Configure the switch with params sent
+-------
+"""
+def config_authentication(module):
+
+    params = module.params
+
+    url = "/authentication"
+
+    if params['config'] == "create":
+        data = {'is_privilege_mode_enabled': True}
+    else:
+        data = {'is_privilege_mode_enabled': False}
+
+    method = 'PUT'
+
+    result = run_commands(module, url, data, method, check=url)
+    return result
+
+"""
+-------
+Name: config_authentication_console
+
+Configures port with authentication config
+
+param request: module
+
+Returns
+ Configure the switch with params sent
+-------
+"""
+def config_authentication_console(module):
+
+    params = module.params
+
+    url = "/authentication/console"
+
+    data = {}
+    data['auth_console_login'] = {'primary_method': params['primary_method'], 'secondary_method': params['secondary_method']}
+
+    method = 'PUT'
+
+    result = run_commands(module, url, data, method, check=url)
+    return result
+
+"""
+-------
+Name: config_authentication_ssh
+
+Configures port with authentication config
+
+param request: module
+
+Returns
+ Configure the switch with params sent
+-------
+"""
+def config_authentication_ssh(module):
+
+    params = module.params
+
+    url = "/authentication/ssh"
+
+    data = {}
+    data['auth_ssh_login'] = {'primary_method': params['primary_method'], 'secondary_method': params['secondary_method']}
+
+    method = 'PUT'
+
+    result = run_commands(module, url, data, method, check=url)
+    return result
+
+"""
+-------
+Name: run_module()
+
+The main module invoked
+
+Returns
+ Configure the switch with params sent
+-------
+"""
+def run_module():
+    module_args = dict(
+        command=dict(type='str', required=False,default='config_authentication',
+           choices=['config_authentication','config_authentication_console','config_authentication_ssh']),
+        config=dict(type='str', required=False, default='create', choices=["create","delete"]),
+        is_privilege_mode_enabled=dict(type='bool', required=False, default=False),
+        primary_method=dict(type='str', required=False, default="PAM_LOCAL",
+           choices=["PAM_LOCAL", "PAM_TACACS"]),
+        secondary_method=dict(type='str', required=False, default="SAM_NONE",
+           choices=["SAM_NONE", "SAM_LOCAL"]),
+    )
+
+    module_args.update(arubaoss_argument_spec)
+
+    result = dict(changed=False,warnings='Not Supported')
+
+    module = AnsibleModule(
+        argument_spec=module_args,
+        supports_check_mode=True
+    )
+
+    if module.check_mode:
+        module.exit_json(**result)
+
+    try:
+        if module.params['command'] == "config_authentication":
+            result = config_authentication(module)
+        elif module.params['command'] == "config_authentication_console":
+            result = config_authentication_console(module)
+        else:
+            result = config_authentication_ssh(module)
+    except Exception as err:
+        return module.fail_json(msg=err)
+
+    module.exit_json(**result)
+
+def main():
+    run_module()
+
+if __name__ == '__main__':
+    main()
diff --git a/ansible/modules/network/arubaoss/arubaoss_aaa_authorization.py b/ansible/modules/network/arubaoss/arubaoss_aaa_authorization.py
new file mode 100644
index 0000000..b597484
--- /dev/null
+++ b/ansible/modules/network/arubaoss/arubaoss_aaa_authorization.py
@@ -0,0 +1,108 @@
+#!/usr/bin/python
+
+ANSIBLE_METADATA = {
+    'metadata_version': '1.1',
+    'status': ['preview'],
+    'supported_by': 'community'
+}
+
+DOCUMENTATION = '''
+---
+module: arubaoss_aaa_authorization
+
+short_description: implements rest api for AAA Authorization configuration
+
+version_added: "2.4"
+
+description:
+    - "This implements rest apis which can be used to configure authorization"
+
+options:
+    authorization_method:
+        description: To authorization method needed
+        choices: AZM_NONE, AZM_TACACS
+        required: False
+
+author:
+    - Sanju Sadanandan (@hpe)
+'''
+
+EXAMPLES = '''
+     - name: Updates the given console authorization configuration to the system
+       arubaoss_aaa_authorization:
+         authorization_method: "AZM_TACACS"
+'''
+
+RETURN = '''
+original_message:
+    description: The original name param that was passed in
+    type: str
+message:
+    description: The output message that the sample module generates
+'''
+
+from ansible.module_utils.basic import AnsibleModule
+from ansible.module_utils.network.arubaoss.arubaoss import run_commands
+from ansible.module_utils.network.arubaoss.arubaoss import arubaoss_argument_spec
+
+"""
+-------
+Name: config
+
+Configures port with authorization config
+
+param request: module
+
+Returns
+ Configure the switch with params sent
+-------
+"""
+def config(module):
+
+    params = module.params
+    data = {'authorization_method': params['authorization_method']}
+    url = '/authorization'
+    method = 'PUT'
+    result = run_commands(module, url, data, method, check=url)
+
+    return result
+"""
+-------
+Name: run_module()
+
+The main module invoked
+
+Returns
+ Configure the switch with params sent
+-------
+"""
+def run_module():
+    module_args = dict(
+        authorization_method=dict(type='str', required=False, default="AZM_NONE",
+                         choices=["AZM_NONE","AZM_TACACS"]),
+    )
+
+    module_args.update(arubaoss_argument_spec)
+
+    result = dict(changed=False,warnings='Not Supported')
+
+    module = AnsibleModule(
+        argument_spec=module_args,
+        supports_check_mode=True
+    )
+
+    if module.check_mode:
+        module.exit_json(**result)
+
+    try:
+        result = config(module)
+    except Exception as err:
+        return module.fail_json(msg=err)
+
+    module.exit_json(**result)
+
+def main():
+    run_module()
+
+if __name__ == '__main__':
+    main()
diff --git a/ansible/modules/network/arubaoss/arubaoss_acl_policy.py b/ansible/modules/network/arubaoss/arubaoss_acl_policy.py
new file mode 100644
index 0000000..d7be3e8
--- /dev/null
+++ b/ansible/modules/network/arubaoss/arubaoss_acl_policy.py
@@ -0,0 +1,476 @@
+#!/usr/bin/python
+
+ANSIBLE_METADATA = {
+    'metadata_version': '1.1',
+    'status': ['preview'],
+    'supported_by': 'community'
+}
+
+DOCUMENTATION = '''
+---
+module: arubaoss_acl_policy
+
+short_description: implements rest api for global acl configuration
+
+version_added: "2.6"
+
+description:
+    - "This implements rest api's which will configure acl policies
+       standard and extended onto device"
+
+options:
+    acl_name:
+        description:
+            - Name for acl policy being configured.
+        required: true
+    acl_type:
+        description:
+            - Type of acl policy to be configured.
+        required: false
+        default: AT_STANDARD_IPV4
+        choices: AT_STANDARD_IPV4, AT_EXTENDED_IPV4,
+                 AT_CONNECTOIN_RATE_FILTER
+    acl_action:
+        description:
+            - Type of action acl will take.
+        required: false
+        choices: AA_DENY, AA_PERMIT
+    remark:
+        description:
+            - Description for acl policy
+        required: false
+    acl_source_address:
+        description:
+            - source ip address for acl policy type standard.
+        required: false
+    acl_source_mask:
+        description:
+            - net mask for source acl_source_address
+        required: false
+    is_log:
+        description:
+            - Enable/disable acl logging.
+        required: false
+    protocol_type:
+        description:
+            - Protocol type for acl filter. Applicable for extended acl.
+        required: false
+        choices: 'PT_GRE','PT_ESP','PT_AH','PT_OSPF','PT_PIM','PT_VRRP',
+                 'PT_ICMP','PTIGMP','PT_IP','PT_SCTP','PT_TCP','PT_UDP'
+    icmp_type:
+        description:
+            - Applies to icmp type matching this field. Only PT_ICMP
+              protocol_type support icmp_code
+        required: false
+    icmp_code:
+        description:
+            - Applies to icmp code matching this field. Only PT_ICMP
+              protocol_type support icmp_code
+        required: false
+    igmp_type:
+        description:
+            - Applies to igmp type matching this field. Only PT_IGMP
+              protocol_type support igmp_type
+        required: false
+    is_connection_established:
+        description:
+            - is_connection_established. Only PT_TCP  protocol_type
+              support is_connection_established
+        required: false
+    match_bit:
+        description:
+            - The set of tcp match bits . Only PT_TCP  protocol_type
+              support match_bit
+        required: false
+    source_port:
+        description:
+            - Applies to source port matching this filter. Only PT_SCTP,
+              PT_TCP and PT_UDP Protocol types support source_port
+        required: false
+    destination_port:
+        description:
+            - Applies to destination port matching this filter. Only
+              PT_SCTP,PT_TCP and PT_UDP Protocol types support destination_port
+        required: false
+    source_ip_address:
+        description:
+            - Applies to source IP Address/Subnet matching this extended acl filter
+        required: false
+    source_ip_mask:
+        description:
+            - Net mask source_ip_address
+        required: false
+    destination_ip_address:
+        description:
+            - Applies to destination IP Address/Subnet matching this extended acl filter
+        required: false
+    device_type:
+        description:
+            - Applies to device type matching this extended acl filter
+        required: false
+    application_type:
+        description:
+            - Applies to application matching this extended acl filter
+        required: fasle
+    precedence:
+        description:
+            - IP precedence flag
+        required: false
+        choices: 0, 1, 2, 3, 4, 5, 6, 7
+    tos:
+        description:
+            - Tos value
+        required: false
+        choices: 0, 2, 4, 8
+    sequece_no:
+        description:
+            - Sequence number for the acl policy configured
+        required: false
+    state:
+        description:
+            - Create or deletes acl policy.
+        required: false
+        default: create
+        choices: create, delete
+
+
+author:
+    - Ashish Pant (@hpe)
+'''
+
+EXAMPLES = '''
+      - name: add extended acl
+        arubaoss_acl_policy:
+          acl_name: test1
+          icmp_code: 1
+          icmp_type: 1
+          source_ip_address: 0.0.0.0
+          source_ip_mask: 255.255.255.255
+          destination_ip_address: 0.0.0.0
+          destination_ip_mask: 255.255.255.255
+          protocol_type: "PT_ICMP"
+          acl_action: AA_PERMIT
+
+      - name: add extended acl
+        arubaoss_acl_policy:
+          acl_name: test
+          icmp_code: 1
+          icmp_type: 1
+          source_ip_address: 0.0.0.0
+          source_ip_mask: 255.255.255.255
+          destination_ip_address: 0.0.0.0
+          destination_ip_mask: 255.255.255.255
+          protocol_type: "PT_ICMP"
+          acl_action: AA_PERMIT
+          acl_type: AT_EXTENDED_IPV4
+
+
+      - name: add standard acl
+        arubaoss_acl_policy:
+          acl_name: "{{item.acl}}"
+          source_ip_address: "{{item.ip}}"
+          acl_action: "{{item.action}}"
+          is_log: "{{item.log}}"
+          remark: testing
+        with_items:
+          - {"acl":"test2","action":"AA_PERMIT","ip":"any","log":False}
+          - {"acl":"test3","action":"AA_PERMIT","ip":"any","log":True}
+
+      - name: delte acl policy
+        arubaoss_acl_policy:
+          acl_name: "{{item}}"
+          state: delete
+        with_items:
+          - test2
+          - test3
+
+'''
+
+RETURN = '''
+original_message:
+    description: The original name param that was passed in
+    type: str
+message:
+    description: The output message that the sample module generates
+'''
+
+from ansible.module_utils.basic import AnsibleModule
+from ansible.module_utils.network.arubaoss.arubaoss import run_commands,get_config
+from ansible.module_utils.network.arubaoss.arubaoss import arubaoss_argument_spec
+from ansible.module_utils._text import to_text
+
+
+def acl(module):
+
+    params = module.params
+
+    url = '/acls'
+    acl_id = params['acl_name'] + '~' + params['acl_type']
+
+    check_url = url + '/' + acl_id
+
+    if params['state'] == 'create':
+
+        data = {
+                'acl_name': params['acl_name'],
+                'acl_type': params['acl_type'],
+                }
+
+        check_list = set(['AT_EXTENDED_IPV4','AT_STANDARD_IPV4','AT_CONNECTION_RATE_FILTER'])\
+                - set([params['acl_type']])
+        for temp in check_list:
+            temp_url = url + '/' + params['acl_name'] + '~' + temp
+            check_acl = get_config(module, temp_url)
+            if check_acl:
+                result = {'msg': '{} already exists for type {}.'.format(params['acl_name'],
+                    temp),'changed':False}
+                module.exit_json(**result)
+        method = 'POST'
+
+    else:
+        # Check if acl is applied to any port
+        port_url = '/ports-access-groups'
+        port_acl = get_config(module, port_url)
+        if port_acl:
+            check_config = module.from_json(to_text(port_acl))
+
+            for ele in check_config['acl_port_policy_element']:
+                if ele['acl_id'] == acl_id:
+                    return {'msg': 'ACL {} applied to port {}'.format(params['acl_name'],
+                        ele['port_id']),'changed':False}
+
+        # Check if acl is applied to any vlan
+        vlan_url = '/vlans-access-groups'
+        vlan_acl = get_config(module, vlan_url)
+        if vlan_acl:
+            check_config = module.from_json(to_text(vlan_acl))
+
+            for ele in check_config['acl_vlan_policy_element']:
+                if ele['acl_id'] == acl_id:
+                    result = {'msg': 'ACL {} applied to vlan {}'.format(params['acl_name'],
+                        ele['vlan_id']),'changed':False}
+                    module.exit_json(**result)
+
+
+        data = {}
+        method = 'DELETE'
+        url = check_url
+
+    result = run_commands(module, url, data, method, check=check_url)
+
+    return result
+
+
+def acl_rule(module):
+
+    params = module.params
+    acl_id = params['acl_name'] + '~' + params['acl_type']
+    url = '/acls/' + acl_id + '/rules'
+
+    # Create acl if not to apply actions
+    if params['state'] == 'create':
+        acl(module)
+
+    method = 'POST'
+    if params['sequence_no'] > 0:
+        url = url + '/' + str(params['sequence_no'])
+        method = 'PUT'
+        data = {'sequence_no': params['sequence_no']}
+    else:
+        data = {}
+
+    if params['state'] == 'create':
+
+
+        data.update({
+            'acl_id': acl_id,
+            'acl_action': params['acl_action'],
+            })
+
+        if params['remark']:
+            data['remark'] = params['remark']
+
+        if params['is_log'] != None:
+            data['is_log'] = params['is_log']
+
+        if params['acl_type'] == 'AT_EXTENDED_IPV4':
+
+            for key in ['source_ip_address','source_ip_mask','destination_ip_address',
+                    'destination_ip_mask']:
+                if params.get(key) == None:
+                    return {'msg':'{} is required for extended acl policy'.format(key),
+                            'changed':False}
+
+            protocol = params.get('protocol_type')
+            if not protocol:
+                return {'msg': 'protocol_type is required','changed':False}
+
+            version = 'IAV_IP_V4'
+
+            data.update({
+                "traffic_match": {
+                    "protocol_type": params['protocol_type'],
+                    "source_ip_address": {
+                        "version": version,
+                        "octets": params['source_ip_address']
+                        },
+                    "source_ip_mask": {
+                        "version": version,
+                        "octets": params['source_ip_mask']
+                        },
+                    "destination_ip_address": {
+                        "version": version,
+                        "octets": params['destination_ip_address']
+                        },
+                    "destination_ip_mask": {
+                        "version": version,
+                        "octets": params['destination_ip_mask']
+                        }
+                    }
+                })
+
+            if protocol == 'PT_ICMP':
+                if params['icmp_type'] > -1:
+                    data['traffic_match']['icmp_type'] = params['icmp_type']
+                if params['icmp_code'] > -1:
+                    data['traffic_match']['icmp_code'] = params['icmp_code']
+
+            if protocol == 'PT_IGMP':
+                if params['igmp_type']:
+                    data['traffic_match']['igmp_type'] = params['igmp_type']
+
+            if protocol == 'PT_TCP':
+                if params['is_connection_established']:
+                    data['traffic_match']['is_connection_established'] = params['is_connection_established']
+
+                if params['match_bit']:
+                    data['traffic_match']['match_bit'] = params['match_bit']
+
+            if protocol in ('PT_SCTP','PT_TCP','PT_UDP'):
+                if params['source_port']:
+                    data['traffic_match']['source_port'] = params['source_port']
+
+                if params['destination_port']:
+                    data['traffic_match']['destination_port'] = params['destination_port']
+
+            if params['precedence']:
+                data['traffic_match']['precedence'] = params['precedence']
+
+            if params['tos']:
+                data['traffic_match']['tos'] = params['tos']
+
+            if params['is_log'] != None:
+                data['is_log'] = params['is_log']
+        else:
+
+            if params['acl_source_address'] == 'host':
+                source_mask = '255.255.255.255'
+                source_ip = '0.0.0.0'
+            else:
+                source_ip = params['acl_source_address']
+                source_mask = params['acl_source_mask']
+
+
+            data.update({
+                'std_source_address': {
+                    'source_ip_address': {
+                        'version': 'IAV_IP_V4',
+                        'octets': source_ip,
+                        },
+                    'source_ip_mask': {
+                        'version': 'IAV_IP_V4',
+                        'octets': source_mask,
+                        }
+                    }
+                })
+
+
+        acl_config = get_config(module, url)
+        if acl_config:
+            check_config = module.from_json(to_text(acl_config))
+            if params['sequence_no'] == 0:
+                for config in check_config['acl_rule_element']:
+                    if acl_id == config['acl_id']:
+                        return config
+            elif params['sequence_no'] > 0:
+                if acl_id == check_config['acl_id']:
+                    result = run_commands(module, url, data, 'PUT', check=url)
+                    return result
+
+        result = run_commands(module, url, data, method)
+    else:
+        if params['sequence_no'] ==0:
+            return {'msg':'sequence_no is required','changed':False}
+
+        result = run_commands(module, url, {}, 'DELETE',check=url)
+
+    return result
+
+
+def run_module():
+    module_args = dict(
+        acl_name=dict(type='str', required=True),
+        acl_type=dict(type='str', required=False,default='AT_STANDARD_IPV4',
+            choices=['AT_EXTENDED_IPV4','AT_STANDARD_IPV4','AT_CONNECTION_RATE_FILTER']),
+        state=dict(type='str', required=False, default='create',
+            choices=['create','delete']),
+        acl_action=dict(type='str', required=False, choices=['AA_DENY','AA_PERMIT']),
+        remark=dict(type='str', required=False),
+        acl_source_address=dict(type='str', required=False,default='0.0.0.0'),
+        acl_source_mask=dict(type='str', required=False, default='255.255.255.255'),
+        is_log=dict(type='bool', required=False),
+        protocol_type=dict(type='str', required=False, choices=['PT_GRE','PT_ESP',
+            'PT_AH','PT_OSPF','PT_PIM','PT_VRRP','PT_ICMP','PTIGMP','PT_IP','PT_SCTP',
+            'PT_TCP','PT_UDP']),
+        icmp_type=dict(type='int', required=False, defualt=-1),
+        icmp_code=dict(type='int', required=False, default=-1),
+        igmp_type=dict(type='str', required=False, choices=['IT_HOST_QUERY',
+            'IT_HOST_REPORT','IT_DVMRP','IT_PIM','IT_TRACE','IT_V2_HOST_REPORT',
+            'IT_V2_HOST_LEAVE','IT_MTRACE_REPLY','IT_MTRACE_REQUEST','IT_V3_HOST_REPORT',
+            'IT_MROUTER_ADVERTISEMENT','IT_MROUTER_SOLICITATION','IT_MROUTER_TERMINATION']),
+        is_connection_established=dict(type='bool', required=False),
+        match_bit=dict(type='list', required=False, choices=['MB_ACK','MB_FIN',
+            'MB_RST','MB_SYN']),
+        source_port=dict(type='dict', required=False),
+        destination_port=dict(type='dict', required=False),
+        source_ip_address=dict(type='str', required=False),
+        source_ip_mask=dict(type='str', required=False),
+        destination_ip_address=dict(type='str', required=False),
+        destination_ip_mask=dict(type='str', required=False),
+        device_type=dict(type='str', required=False,),
+        application_type=dict(type='str', required=False),
+        precedence=dict(type='int', required=False, choices=[0,1,2,3,4,5,6,7]),
+        tos=dict(type='int', required=False,choices=[0,2,4,8]),
+        sequence_no=dict(type='int', required=False, default=0),
+
+    )
+
+    module_args.update(arubaoss_argument_spec)
+
+    result = dict(changed=False,warnings='Not Supported')
+
+    module = AnsibleModule(
+        argument_spec=module_args,
+        supports_check_mode=True
+    )
+
+    if module.check_mode:
+        module.exit_json(**result)
+    try:
+
+        if module.params['acl_action']:
+            result = acl_rule(module)
+        else:
+            result = acl(module)
+
+    except Exception as err:
+        return module.fail_json(msg=err)
+
+    module.exit_json(**result)
+
+
+def main():
+    run_module()
+
+if __name__ == '__main__':
+    main()
diff --git a/ansible/modules/network/arubaoss/arubaoss_captive_portal.py b/ansible/modules/network/arubaoss/arubaoss_captive_portal.py
new file mode 100644
index 0000000..b3cade0
--- /dev/null
+++ b/ansible/modules/network/arubaoss/arubaoss_captive_portal.py
@@ -0,0 +1,139 @@
+#!/usr/bin/python
+
+ANSIBLE_METADATA = {
+    'metadata_version': '1.1',
+    'status': ['preview'],
+    'supported_by': 'community'
+}
+
+DOCUMENTATION = '''
+---
+module: arubaoss_captive_portal
+
+short_description: Implements Ansible module for captive portal configuration.
+
+version_added: "2.6"
+
+description:
+    - "This implement rest api's which can be used to configure captive portal
+       on devices"
+
+options:
+    profile_name:
+        description:
+            - captive portal profile name
+        required: false
+    server_url:
+        description:
+            - url for captive portal server
+        required: false
+    enable_captive_portal:
+        description:
+            - enable/disable captive portal on device
+        required: false
+    url_hash_key:
+        description:
+            - Hash key to verify integrity of the captive url
+        required: false
+    state:
+        description:
+            - Update or read captive protal data
+        required: false
+
+
+author:
+    - Ashish Pant (@hpe)
+'''
+
+EXAMPLES = '''
+      - name: enable/disable captive portal
+        arubaoss_captive_portal:
+          enable_captive_portal: "{{item}}"
+        with_items:
+          - False
+          - True
+
+      - name: add custom captive portal
+        arubaoss_captive_portal:
+          profile_name: "{{item}}"
+          server_url: "http://hpe.com"
+        with_items:
+          - test1
+          - test2
+
+      - name: add/remove url_has
+        arubaoss_captive_portal:
+          url_hash_key: "{{item}}"
+        with_items:
+          - ""
+          - test1
+
+'''
+
+from ansible.module_utils.basic import AnsibleModule
+from ansible.module_utils.network.arubaoss.arubaoss import run_commands,get_config
+from ansible.module_utils.network.arubaoss.arubaoss import arubaoss_argument_spec
+from ansible.module_utils._text import to_text
+
+
+def config_captive_portal(module):
+
+    params = module.params
+
+    url = '/captive_portal'
+
+    if params['state'] == 'create':
+        data = {'is_captive_portal_enabled': params['enable_captive_portal']}
+
+        if params.get('url_hash_key') != None:
+            data['url_hash_key'] = params['url_hash_key']
+
+        if params['profile_name']:
+            data['custom_profile'] = {
+                    'profile': params['profile_name'],
+                    'url': params['server_url']
+                    }
+
+        result = run_commands(module, url,data, 'PUT', url)
+
+    else:
+        result = get_config(module, url)
+
+    return result
+
+
+def run_module():
+    module_args = dict(
+        profile_name=dict(type='str', required=False),
+        server_url=dict(type='str', required=False, default=""),
+        enable_captive_portal=dict(type='bool', required=False, default=True),
+        url_hash_key=dict(type='str', required=False),
+        state=dict(type='str', required=False, default='create'),
+    )
+
+    module_args.update(arubaoss_argument_spec)
+
+    result = dict(changed=False,warnings='Not Supported')
+
+    module = AnsibleModule(
+        argument_spec=module_args,
+        supports_check_mode=True
+    )
+
+    if module.check_mode:
+        module.exit_json(**result)
+
+    else:
+        try:
+            result = config_captive_portal(module)
+        except Exception as err:
+            return module.fail_json(msg=err)
+
+    module.exit_json(**result)
+
+
+def main():
+    run_module()
+
+if __name__ == '__main__':
+    main()
diff --git a/ansible/modules/network/arubaoss/arubaoss_config_bkup.py b/ansible/modules/network/arubaoss/arubaoss_config_bkup.py
new file mode 100644
index 0000000..d622ecb
--- /dev/null
+++ b/ansible/modules/network/arubaoss/arubaoss_config_bkup.py
@@ -0,0 +1,265 @@
+#!/usr/bin/python
+
+ANSIBLE_METADATA = {
+    'metadata_version': '1.1',
+    'status': ['preview'],
+    'supported_by': 'community'
+}
+
+DOCUMENTATION = '''
+---
+module: arubaoss_config_bkup
+
+short_description: Implements Ansible module for switch configuration
+                   backup and restore.
+
+version_added: "2.6"
+
+description:
+    - "This implement rest api's which can be used to backup switch
+       configuration from server. Module takes 5 secs to execute each
+       task. Defualt module action is to restore the configuration.
+       Use config_type for configuration backup"
+
+options:
+    filne_name:
+        description:
+            - configuration file name
+        required: true
+    config_type:
+        description:
+            - Type of configuration file. If this option is used, configuration
+              file is saved to the system.
+        choices: CT_RUNNING_CONFIG, CT_STARTUP_CONFIG
+        required: false
+    server_type:
+        description:
+            - server type from/to which configuration needs to be copied
+        choices: ST_FLASH, ST_TFTP, ST_SFTP
+        required: false
+    forced_reboot:
+        description:
+            - Apply the configuration with reboot if the configuration
+              has reboot required commands
+        required: false
+    recover_mode:
+        description:
+            - To enable or disable recovery mode. Not applicable if
+              is_forced_reboot_enabled is true
+        required: false
+    server_name:
+        description:
+            - Server name in which file is stored. Not applicable for ST_FLASH.
+        required: false
+    server_ip:
+        description:
+            - Server ip address in which file is stored. Not applicable for
+              ST_FLASH
+        required: false
+    sftp_port:
+        description:
+            - TCP port number. Applicable for ST_SFTP.
+        default: 22
+        required: false
+    wait_for_apply:
+        description:
+            - Wait if there is already an ongoing configuration change on device.
+        defualt: True
+        required: false
+    state:
+        description:
+            - Adding or reading data
+        default: create
+        required: false
+
+
+author:
+    - Ashish Pant (@hpe)
+'''
+
+EXAMPLES = '''
+      - name: backup configuration files
+        arubaoss_config_bkup:
+          file_name: test1
+          server_type: ST_TFTP
+          server_ip: 192.168.1.2
+
+      - name: backup configuration files
+        arubaoss_config_bkup:
+          file_name: test1
+          config_type: CT_RUNNING_CONFIG
+
+'''
+
+from ansible.module_utils.basic import AnsibleModule
+from ansible.module_utils.network.arubaoss.arubaoss import run_commands,get_config
+from ansible.module_utils.network.arubaoss.arubaoss import arubaoss_argument_spec
+from ansible.module_utils._text import to_text
+from time import sleep
+
+
+def config_backup(module):
+
+    params = module.params
+    url = '/system/config/cfg_backup_files'
+
+    data = {
+            'file_name': params['file_name'],
+            'config_type': params['config_type']
+            }
+
+    if params['state'] == 'create':
+        check_config = get_config(module, url)
+        if check_config:
+            check_config = module.from_json(to_text(check_config))
+            if check_config['collection_result']['total_elements_count'] == 5:
+                present = False
+                for config in check_config['config_file_element']:
+                    if config['file_name'] == params['file_name']:
+                        present = True
+                if not present:
+                    return {'msg':'Only five config files are allowed.','changed':False}
+
+        result = run_commands(module, url, data, 'POST')
+
+    return result
+
+
+def config_restore(module):
+    params = module.params
+    url = '/system/config/cfg_restore'
+    url_status = url + '/status'
+
+    server_type = params['server_type']
+    data = {
+            'file_name': params['file_name'],
+            'server_type': server_type,
+            }
+
+    if server_type == 'ST_TFTP' or server_type == 'ST_SFTP':
+        if not params['server_name'] and not params['server_ip']:
+            return {'msg': 'server_name or server_ip is required','changed':False}
+
+    if server_type == 'ST_TFTP':
+        if params['server_name']:
+            data.update({
+                'tftp_server_address': {
+                    'server_address': {
+                        'host_name' : params['server_name']
+                        }
+                    }
+                })
+        if params['server_ip']:
+            data.update({
+                'tftp_server_address': {
+                    'server_address': {
+                        'ip_address' : {
+                            'octets': params['server_ip'],
+                            'version': 'IAV_IP_V4'
+                            }
+                        }
+                    }
+                })
+
+    if server_type == 'ST_FFTP':
+        if params['server_ip']:
+            data.update({
+                'sftp_server_address': {
+                    'server_address': {
+                        'host_name': params['server_name']
+                        }
+                    }
+                })
+        if params['server_name']:
+            data.update({
+                'sftp_server_address': {
+                    'server_address': {
+                        'ip_address' : {
+                            'octets': params['server_ip'],
+                            'version': 'IAV_IP_V4'
+                            }
+                        }
+                    }
+                })
+
+        data['sftp_server_address']['user_name'] == params['username']
+        data['sftp_server_address']['password'] == params['password']
+        port = params['sftp_port']
+        if port < 1 or port > 65535:
+            return {'msg': 'sftp_port range should be between 1-65535','changed':False}
+
+        data['sftp_server_address']['port_number'] = params['sftp_port']
+
+
+    # Wait 40 secs for configuration to be applied
+    for _ in range(20):
+        get_status = get_config(module, url_status)
+        if get_status:
+            get_status = module.from_json(to_text(get_status))
+            status = get_status['status']
+            if status in ['CRS_IN_PROGRESS', 'CRS_FINDING_FAILED_CMDS',
+                    'CRS_CALCULATING_DIFF']:
+                if params['wait_for_apply']:
+                    sleep(2)
+                    module.log(status['status'])
+                    continue
+                else:
+                    return {'msg': 'Config restore is already running: {}'.format(status),
+                            'changed':False}
+        break
+
+
+    result = run_commands(module, url, data, 'POST',wait_after_send=5)
+    message = result.get('body') or None
+    if message and 'Configuration changes are temporarily disabled' in message:
+        ret = {'message': message}
+        ret['changed'] = False
+        return ret
+
+    return result
+
+
+def run_module():
+    module_args = dict(
+        file_name=dict(type='str', required=True),
+        config_type=dict(type='str', required=False,
+            choices=['CT_RUNNING_CONFIG','CT_STARTUP_CONFIG']),
+        server_type=dict(type='str', required=False,
+            choices=['ST_FLASH','ST_TFTP','ST_SFTP']),
+        forced_reboot=dict(type='bool', required=False),
+        recovery_mode=dict(type='bool', required=False),
+        server_name=dict(type='str', required=False),
+        server_ip=dict(type='str', required=False),
+        sftp_port=dict(type='int', required=False, default=22),
+        state=dict(type='str', required=False, default='create'),
+        wait_for_apply=dict(type='bool', required=False, default=True),
+    )
+
+    module_args.update(arubaoss_argument_spec)
+
+    result = dict(changed=False,warnings='Not Supported')
+
+    module = AnsibleModule(
+        argument_spec=module_args,
+        supports_check_mode=True
+    )
+
+    if module.check_mode:
+        module.exit_json(**result)
+    try:
+        if module.params['config_type']:
+            result = config_backup(module)
+        else:
+            result = config_restore(module)
+
+    except Exception as err:
+        return module.fail_json(msg=err)
+
+    module.exit_json(**result)
+
+
+def main():
+    run_module()
+
+if __name__ == '__main__':
+    main()
diff --git a/ansible/modules/network/arubaoss/arubaoss_dns.py b/ansible/modules/network/arubaoss/arubaoss_dns.py
new file mode 100644
index 0000000..8920ad3
--- /dev/null
+++ b/ansible/modules/network/arubaoss/arubaoss_dns.py
@@ -0,0 +1,182 @@
+#!/usr/bin/python
+
+ANSIBLE_METADATA = {
+    'metadata_version': '1.1',
+    'status': ['preview'],
+    'supported_by': 'community'
+}
+
+DOCUMENTATION = '''
+---
+module: arubaoss_dns
+
+short_description: implements rest api for DNS configuration
+
+version_added: "2.4"
+
+description:
+    - "This implements rest apis which can be used to configure DNS"
+
+options:
+    dns_config_mode:
+        description: DNS Configuration Mode, default is DCM_DHCP
+        choices: DCM_DHCP, DCM_MANUAL, DCM_DISABLED
+        required: False
+    dns_domain_names:
+        description: Array of manually configured DNS server domain names
+        required: False
+    server_1:
+        description: The first manually configured DNS Server.
+        required: False
+    version_1:
+        description: The ip version of first manually configured DNS Server.
+        choices: IAV_IP_V4. (V6 is not supported via REST)
+        required: False
+    server_2:
+        description: The second manually configured DNS Server.
+        required: False
+    version_2:
+        description: The ip version of second manually configured DNS Server.
+        choices: IAV_IP_V4. (V6 is not supported via REST)
+        required: False
+    server_3:
+        description: The third manually configured DNS Server.
+        required: False
+    version_3:
+        description: The ip version of third manually configured DNS Server.
+        choices: IAV_IP_V4. (V6 is not supported via REST)
+        required: False
+    server_4:
+        description: The fourth manually configured DNS Server.
+        required: False
+    version_4:
+        description: The ip version of fourth manually configured DNS Server.
+        choices: IAV_IP_V4. (V6 is not supported via REST)
+        required: False
+
+author:
+    - Sanju Sadanandan (@hpe)
+'''
+
+EXAMPLES = '''
+- name: Updates the given console DNS Server configuration to the system
+       arubaoss_dns:
+         dns_config_mode: "DCM_MANUAL"
+         dns_domain_names: ["mydomain.com",
+                             "myotherdomain.com"]
+         version_1: "IAV_IP_V4"
+         server_1: "10.2.3.4"
+         version_2: "IAV_IP_V4"
+         server_2: "10.2.3.5"
+         version_3: "IAV_IP_V4"
+         server_3: "10.2.3.6"
+         version_4: "IAV_IP_V4"
+         server_4: "10.2.3.7"
+
+'''
+
+
+from ansible.module_utils.basic import AnsibleModule
+from ansible.module_utils.network.arubaoss.arubaoss import run_commands
+from ansible.module_utils.network.arubaoss.arubaoss import arubaoss_argument_spec
+
+"""
+-------
+Name: config
+
+Configures port with system_attributes config
+
+param request: module
+
+Returns
+ Configure the switch with params sent
+-------
+"""
+def config(module):
+
+    params = module.params
+    dnsList = []
+    dnsServerList = []
+    idval = 1
+    data = {'dns_config_mode': params['dns_config_mode']}
+
+    # Configure the domain names
+    for dns in {params['dns_domain_names'], params['dns_domain_names_2'],
+          params['dns_domain_names_3'], params['dns_domain_names_4'], params['dns_domain_names_5']}:
+        if not dns == "" and dns not in dnsList:
+            dnsList.append(dns)
+    data['dns_domain_names'] = dnsList
+
+    # Configure the dns servers
+    for dnsServer in {params['server_1'], params['server_2'], params['server_3'], params['server_4']}:
+        if not dnsServer == "" and dnsServer not in dnsServerList:
+            dnsServerList.append(dnsServer)
+            server = 'server_' + str(idval)
+            version = 'version_' + str(idval)
+
+            # Only IPv4 address supported
+            if not params[version] == "IAV_IP_V4":
+                return {'msg': 'Only IPv4 address mode is supported',
+                    'changed': False, 'failed': False}
+
+            data[server] =  {'version': params[version], 'octets': params[server]}
+        idval = idval + 1
+
+    url = '/dns'
+    method = 'PUT'
+
+    result = run_commands(module, url, data, method, check=url)
+    return result
+"""
+-------
+Name: run_module()
+
+The main module invoked
+
+Returns
+ Configure the switch with params sent
+-------
+"""
+def run_module():
+    module_args = dict(
+        dns_config_mode=dict(type='str', required=False,default="DCM_MANUAL",
+              choices=["DCM_DHCP", "DCM_MANUAL", "DCM_DISABLED"]),
+        dns_domain_names=dict(type='str', required=False, default=""),
+        dns_domain_names_2=dict(type='str', required=False, default=""),
+        dns_domain_names_3=dict(type='str', required=False, default=""),
+        dns_domain_names_4=dict(type='str', required=False, default=""),
+        dns_domain_names_5=dict(type='str', required=False, default=""),
+        server_1=dict(type='str', required=False, default=""),
+        version_1=dict(type='str', required=False, default="IAV_IP_V4", choices=["IAV_IP_V4"]),
+        server_2=dict(type='str', required=False, default=""),
+        version_2=dict(type='str', required=False, default="IAV_IP_V4", choices=["IAV_IP_V4"]),
+        server_3=dict(type='str', required=False, default=""),
+        version_3=dict(type='str', required=False, default="IAV_IP_V4", choices=["IAV_IP_V4"]),
+        server_4=dict(type='str', required=False, default=""),
+        version_4=dict(type='str', required=False, default="IAV_IP_V4", choices=["IAV_IP_V4"]),
+    )
+
+    module_args.update(arubaoss_argument_spec)
+
+    result = dict(changed=False,warnings='Not Supported')
+
+    module = AnsibleModule(
+        argument_spec=module_args,
+        supports_check_mode=True
+    )
+
+    if module.check_mode:
+        module.exit_json(**result)
+
+    try:
+        result = config(module)
+    except Exception as err:
+        return module.fail_json(msg=err)
+
+    module.exit_json(**result)
+
+def main():
+    run_module()
+
+if __name__ == '__main__':
+    main()
diff --git a/ansible/modules/network/arubaoss/arubaoss_dot1x.py b/ansible/modules/network/arubaoss/arubaoss_dot1x.py
new file mode 100644
index 0000000..a69b213
--- /dev/null
+++ b/ansible/modules/network/arubaoss/arubaoss_dot1x.py
@@ -0,0 +1,458 @@
+#!/usr/bin/python
+
+ANSIBLE_METADATA = {
+    'metadata_version': '1.1',
+    'status': ['preview'],
+    'supported_by': 'community'
+}
+
+DOCUMENTATION = '''
+---
+module: arubaoss_dot1x
+
+short_description: implements rest api for DOT1x configuration
+
+version_added: "2.4"
+
+description:
+    - "This implements rest apis which can be used to configure DOT1x"
+
+options:
+    command:
+        description: Module to be configured.
+        choices: dot1x_config, authenticator_port_config, authentication_method_config, dot1x_port_security,
+                 authenticator_port_clearstats, authenticator_port_initialize, authenticator_port_reauthenticate
+        required: False
+    is_dot1x_enabled:
+        description: Global 802.1x admin status
+        required: False
+    cached_reauth_delay:
+        description: Global 802.1x cached reauth delay
+        required: False
+    allow_gvrp_vlans:
+        description:  allow GVRP vlans
+        required: False
+    use_lldp_data:
+        description: Use LLDP data
+        required: False
+    port_id:
+        description: Port ID
+        required: False
+    is_authenticator_enabled:
+        description: 802.1X Authenticator Port admin status
+        required: False
+    control:
+        description: 802.1X Authenticator Port operational control
+        required: False
+        choices: DAPC_UNAUTHORIZED, DAPC_AUTO, DAPC_AUTHORIZED
+    unauthorized_vlan_id:
+        description: 802.1X unauthorized VLAN ID. Displays 0 if not configured. Use 0 to reset unauthorized_vlan_id.
+        required: False
+    client_limit:
+        description: Client limit
+        required: False
+    quiet_period: Quiet Period
+        description:
+        required: False
+    tx_period:
+        description: Tx Period
+        required: False
+    supplicant_timeout:
+        description: Supplicant timeout, default= 30
+        required: False
+    server_timeout:
+        description: Server timeout, default= 300
+        required: False
+    max_requests:
+        description: Max requests, default =2
+        required: False
+    reauth_period:
+        description: Reauth Period
+        required: False
+    authorized_vlan_id:
+        description: 802.1X authorized VLAN ID. Displays 0 if not configured.
+                     Use 0 to reset authorized_vlan_id
+        required: False
+    logoff_period:
+        description: Logoff Period, default = 300
+        required: False
+    unauth_period:
+        description: Unauth period, default = 0
+        required: False
+    cached_reauth_period:
+        description: Cached reauth period, default = 0
+        required: False
+    enforce_cache_reauth:
+        description: Authenticator enforce canched reauthentication
+        required: False
+    server_timeout:
+        description:
+        required: False
+    supplicant_timeout:
+        description:
+        required: False
+    primary_authentication_method:
+        description: The primary authentication method
+        choices: DPAM_LOCAL, DPAM_EAP_RADIUS, DPAM_CHAP_RADIUS
+        required: False
+    secondary_authentication_method:
+        description: The secondary authentication method
+        choices: DSAM_NONE, DSAM_AUTHORIZED, DSAM_CACHED_REAUTH
+        required: False
+    server_group:
+        description: The server group
+        required: False
+    controlled_direction:
+        description: Traffic Controlled direction
+        choices: DCD_IN, DCD_OUT
+        required: False
+    allow_mbv:
+        description: Configuration of MAC based Vlans
+        required: False
+    allow_mixed_users:
+        description: Allowed users
+        required: False
+    is_port_speed_vsa_enabled:
+        description: Is port speed VSA enabled
+        required: False
+
+author:
+    - Sanju Sadanandan (@hpe)
+'''
+
+EXAMPLES = '''
+     - name: Updates the given console dot1x configuration to the system
+       arubaoss_aaa_dot1x:
+         server_group: "AZM_TACACS"
+'''
+
+import json
+from ansible.module_utils.basic import AnsibleModule
+from ansible.module_utils.network.arubaoss.arubaoss import run_commands
+from ansible.module_utils.network.arubaoss.arubaoss import get_config
+from ansible.module_utils.network.arubaoss.arubaoss import arubaoss_argument_spec
+"""
+-------
+Name: dot1x_config
+
+Updates the given 802.1X Port security in the model
+
+param request: module
+
+Returns
+ Configure the switch with params sent
+-------
+"""
+def dot1x_config(module):
+
+    params = module.params
+    data = {}
+
+    data['is_dot1x_enabled'] = params['is_dot1x_enabled']
+    data['cached_reauth_delay'] = params['cached_reauth_delay']
+    data['allow_gvrp_vlans'] = params['allow_gvrp_vlans']
+    data['use_lldp_data'] = params['use_lldp_data']
+
+    url = '/dot1x'
+    method = 'PUT'
+
+    result = run_commands(module, url, data, method, check=url)
+    return result
+
+"""
+-------
+Name: authenticator_port_config
+
+Updates the given 802.1X Authenticator Port in the model
+
+param request: module
+
+Returns
+ Configure the switch with params sent
+-------
+"""
+def authenticator_port_config(module):
+
+    params = module.params
+
+    data = {}
+    data['port_id'] = params['port_id']
+    if params['port_id'] == "":
+        return {'msg': 'Port_id cannot be null',
+                'changed': False, 'failed': False}
+
+    data['is_authenticator_enabled'] = params['is_authenticator_enabled']
+    data['control'] = params['control']
+    data['unauthorized_vlan_id'] = params['unauthorized_vlan_id']
+    data['client_limit'] = params['client_limit']
+    data['quiet_period'] = params['quiet_period']
+    data['tx_period'] = params['tx_period']
+    data['supplicant_timeout'] = params['supplicant_timeout']
+    data['server_timeout'] = params['server_timeout']
+    data['max_requests'] = params['max_requests']
+    data['reauth_period'] = params['reauth_period']
+    data['authorized_vlan_id'] = params['authorized_vlan_id']
+    data['logoff_period'] = params['logoff_period']
+    data['unauth_period'] = params['unauth_period']
+    data['cached_reauth_period'] = params['cached_reauth_period']
+    data['enforce_cache_reauth'] = params['enforce_cache_reauth']
+
+    url = '/dot1x/authenticator/' + params['port_id']
+    method = 'PUT'
+
+    # Check if authentication is enabled
+    check_presence = get_config(module, "/dot1x")
+    if check_presence:
+        newdata = json.loads(check_presence)
+        if not newdata["is_dot1x_enabled"]:
+            return {'msg': 'Cannot enable port authentication unless dot1x is enabled',
+                'changed': False, 'failed': False}
+
+    result = run_commands(module, url, data, method, check=url)
+    return result
+
+"""
+-------
+Name: authentication_method_config
+
+Configures port with dot1x authentication method
+
+param request: module
+
+Returns
+ Configure the switch with params sent
+-------
+"""
+def authentication_method_config(module):
+
+    params = module.params
+    data = {'server_group': params['server_group']}
+    data['primary_authentication_method'] = params['primary_authentication_method']
+    data['secondary_authentication_method'] = params['secondary_authentication_method']
+
+    url = '/dot1x/authentication_method'
+    method = 'PUT'
+
+    result = run_commands(module, url, data, method, check=url)
+    return result
+"""
+-------
+Name: dot1x_port_security
+
+Updates the given 802.1X Port security in the model
+
+param request: module
+
+Returns
+ Configure the switch with params sent
+-------
+"""
+def dot1x_port_security(module):
+
+    params = module.params
+    data = {}
+    data['port_id'] = params['port_id']
+    if params['port_id'] == "":
+        return {'msg': 'Port_id cannot be null',
+                'changed': False, 'failed': False}
+    data['is_port_speed_vsa_enabled'] = params['is_port_speed_vsa_enabled']
+    data['allow_mbv'] = params['allow_mbv']
+    data['controlled_direction'] = params['controlled_direction']
+    data['allow_mixed_users'] = params['allow_mixed_users']
+
+    url = '/dot1x/port_security/' + params['port_id']
+    method = 'PUT'
+
+    # Check if authentication is enabled
+    check_presence = get_config(module, "/dot1x")
+    if check_presence:
+        newdata = json.loads(check_presence)
+        if not newdata["is_dot1x_enabled"]:
+            return {'msg': 'Cannot enable port security unless dot1x is enabled',
+                'changed': False, 'failed': False}
+
+    result = run_commands(module, url, data, method, check=url)
+    return result
+
+
+"""
+-------
+Name: authenticator_port_initialize
+
+Initialize of dot1x authenticator based on port id
+
+param request: module
+
+Returns
+ Configure the switch with params sent
+-------
+"""
+def authenticator_port_initialize(module):
+
+    params = module.params
+    data = {}
+    data['port_id'] = params['port_id']
+    if params['port_id'] == "":
+        return {'msg': 'Port_id cannot be null',
+                'changed': False, 'failed': False}
+
+    url = '/dot1x/authenticator/' + str(params['port_id']) +'/initialize'
+    method = 'POST'
+
+    # Check if authentication is enabled
+    check_presence = get_config(module, "/dot1x")
+    if check_presence:
+        newdata = json.loads(check_presence)
+        if not newdata["is_dot1x_enabled"]:
+            return {'msg': 'Cannot intialise port unless dot1x is enabled',
+                'changed': False, 'failed': False}
+
+    result = run_commands(module, url, data, method, check=url)
+    return result
+
+"""
+-------
+Name: authenticator_port_reauthenticate
+
+Reauthenticate of dot1x authenticator based on port id
+
+param request: module
+
+Returns
+ Configure the switch with params sent
+-------
+"""
+def authenticator_port_reauthenticate(module):
+
+    params = module.params
+    data = {}
+    data['port_id'] = params['port_id']
+    if params['port_id'] == "":
+        return {'msg': 'Port_id cannot be null',
+                'changed': False, 'failed': False}
+
+    url = '/dot1x/authenticator/' + params['port_id'] +'/reauthenticate'
+    method = 'POST'
+
+    # Check if authentication is enabled
+    check_presence = get_config(module, "/dot1x")
+    if check_presence:
+        newdata = json.loads(check_presence)
+        if not newdata["is_dot1x_enabled"]:
+            return {'msg': 'Cannot reauthenticate port unless dot1x is enabled',
+                'changed': False, 'failed': False}
+
+    result = run_commands(module, url, data, method, check=url)
+    return result
+
+"""
+-------
+Name: authenticator_port_clearstats
+
+Clear statistics of dot1x authenticator based on port id
+
+param request: module
+
+Returns
+ Configure the switch with params sent
+-------
+"""
+def authenticator_port_clearstats(module):
+
+    params = module.params
+    data = {}
+    data['port_id'] = params['port_id']
+    if params['port_id'] == "":
+        return {'msg': 'Port_id cannot be null',
+                'changed': False, 'failed': False}
+
+    url = '/dot1x/authenticator/' + params['port_id'] +'/clearstats'
+    method = 'POST'
+
+    result = run_commands(module, url, data, method)
+    return result
+
+"""
+-------
+Name: run_module()
+
+The main module invoked
+
+Returns
+ Configure the switch with params sent
+-------
+"""
+def run_module():
+    module_args = dict(
+        command=dict(type='str', required=False, default="dot1x_config",
+            choices = ['dot1x_config', 'authenticator_port_config', 'authentication_method_config', 'dot1x_port_security', 'authenticator_port_clearstats', 'authenticator_port_reauthenticate', 'authenticator_port_initialize']),
+        is_dot1x_enabled=dict(type='bool', required=False, default= False),
+        cached_reauth_delay=dict(type='int', required=False, default=0),
+        allow_gvrp_vlans=dict(type='bool', required=False, default=False),
+        use_lldp_data=dict(type='bool', required=False, default=False),
+        server_group=dict(type='str', required=False, default=""),
+        primary_authentication_method=dict(type='str', required=False, default='DPAM_LOCAL',
+            choices = ['DPAM_LOCAL', 'DPAM_EAP_RADIUS', 'DPAM_CHAP_RADIUS']),
+        secondary_authentication_method=dict(type='str', required=False, default='DSAM_NONE',
+            choices = ['DSAM_NONE', 'DSAM_AUTHORIZED', 'DSAM_CACHED_REAUTH']),
+        port_id=dict(type='str', required=False, default=""),
+        logoff_period=dict(type='int', required=False, default=0),
+        is_authenticator_enabled=dict(type='bool', required=False, default=False),
+        control=dict(type='str', required=False, default="DAPC_AUTO",
+            choices = ["DAPC_UNAUTHORIZED", "DAPC_AUTO", "DAPC_AUTHORIZED"]),
+        unauthorized_vlan_id=dict(type='int', required=False, default=0),
+        client_limit=dict(type='int', required=False, default=0),
+        quiet_period=dict(type='int', required=False, default=0),
+        tx_period=dict(type='int', required=False, default=0),
+        supplicant_timeout=dict(type='int', required=False, default=0),
+        server_timeout=dict(type='int', required=False, default=0),
+        max_requests=dict(type='int', required=False, default=0),
+        reauth_period=dict(type='int', required=False, default=0),
+        authorized_vlan_id=dict(type='int', required=False, default=0),
+        unauth_period=dict(type='int', required=False, default=0),
+        cached_reauth_period=dict(type='int', required=False, default=0),
+        enforce_cache_reauth=dict(type='bool', required=False, default=False),
+        is_port_speed_vsa_enabled=dict(type='bool', required=False, default=False),
+        allow_mbv=dict(type='bool', required=False, default=False),
+        controlled_direction=dict(type='str', required=False, default='DCD_BOTH',
+            choices = ['DCD_BOTH', 'DCD_IN']),
+        allow_mixed_users=dict(type='bool', required=False, default=False),
+    )
+
+    module_args.update(arubaoss_argument_spec)
+
+    result = dict(changed=False,warnings='Not Supported')
+
+    module = AnsibleModule(
+        argument_spec=module_args,
+        supports_check_mode=True
+    )
+
+    if module.check_mode:
+        module.exit_json(**result)
+
+    try:
+        if module.params['command'] == "dot1x_config":
+            result = dot1x_config(module)
+        elif module.params['command'] == "authenticator_port_config":
+            result = authenticator_port_config(module)
+        elif module.params['command'] == "authenticator_port_clearstats":
+            result = authenticator_port_clearstats(module)
+        elif module.params['command'] == "authenticator_port_initialize":
+            result = authenticator_port_initialize(module)
+        elif module.params['command'] == "authenticator_port_reauthenticate":
+            result = authenticator_port_reauthenticate(module)
+        elif module.params['command'] == "dot1x_port_security":
+            result = dot1x_port_security(module)
+        else:
+            result = authentication_method_config(module)
+    except Exception as err:
+        return module.fail_json(msg=err)
+
+    module.exit_json(**result)
+
+def main():
+    run_module()
+
+if __name__ == '__main__':
+    main()
diff --git a/ansible/modules/network/arubaoss/arubaoss_file_transfer.py b/ansible/modules/network/arubaoss/arubaoss_file_transfer.py
new file mode 100644
index 0000000..a5c758d
--- /dev/null
+++ b/ansible/modules/network/arubaoss/arubaoss_file_transfer.py
@@ -0,0 +1,136 @@
+#!/usr/bin/python
+
+ANSIBLE_METADATA = {
+    'metadata_version': '1.1',
+    'status': ['preview'],
+    'supported_by': 'community'
+}
+
+DOCUMENTATION = '''
+---
+module: arubaoss_file_transfer
+
+short_description: implements rest api's for file transfer from/to device
+
+version_added: "2.6"
+
+description:
+    - "This implements rest api's for file transfer from/to device. The
+       file get copied to from a http/https server. Server needs to be
+       pre-configured to make use of this module. This module will not
+       do firmware-ugrade but can copy image to flash. User can then
+       use arubaoss_reboot to bringup device with that flash, thus
+       provides firmware-upgrade"
+
+options:
+    file_url:
+        description:
+            - Location of the file to which file needs to be transfered
+              or from file needs to downloded to switch. This is http/https
+              server, which needs to configured with default ports.
+        required: True
+    file_type:
+        description:
+            - Type of file that needs to be transfered. Defualt is
+            firmware.
+        required: false
+    action:
+        description:
+            - Type of action upload/download. Default is download.
+        required: False
+    show_tech_option:
+        description:
+            - Specifies type of show tech command to be executed.
+        required: false
+    boot_image:
+        description:
+            - Flash where image needs to be copied
+
+
+author:
+    - Ashish Pant (@hpe)
+'''
+
+EXAMPLES = '''
+      - name: image download
+        arubaoss_file_transfer:
+          file_url: "http://192.168.1.2/WC_16_07_REL_XANADU_QA_062618.swi"
+          file_type: "FTT_FIRMWARE"
+          action: "FTA_DOWNLOAD"
+
+'''
+
+from ansible.module_utils.basic import AnsibleModule
+from ansible.module_utils.network.arubaoss.arubaoss import run_commands
+from ansible.module_utils.network.arubaoss.arubaoss import arubaoss_argument_spec
+import sys
+
+
+def transfer(module):
+
+    params = module.params
+    url = '/file-transfer'
+    data = {
+            'file_type': params['file_type'],
+            'action': params['action'],
+            'url': params['file_url'],
+            }
+    if params['show_tech_option']:
+        data['show_tech_option'] = params['show_tech_option']
+
+    if params['boot_image']:
+        data['boot_image'] = params['boot_image']
+
+    result = run_commands(module, url, data, 'POST')
+
+    message = result.get('body') or None
+    if message and 'Another download is in progress' in message:
+        result = {'changed': False}
+        result['failed'] = False
+        result['message'] = 'Another download is in progress'
+
+    return result
+
+
+def run_module():
+    module_args = dict(
+        file_type=dict(type='str', required=False, default='FTT_FIRMWARE',
+            choices=['FTT_CONFIG','FTT_FIRMWARE','FTT_EVENT_LOGS',
+                     'FTT_CRASH_FILES','FTT_SYSTEM_INFO','FTT_SHOW_TECH',
+                     'FTT_DEBUG_LOGS']),
+        file_url=dict(type='str', required=True),
+        action=dict(type='str', required=False, default='FTA_DOWNLOAD',
+            choices=['FTA_DOWNLOAD','FTA_UPLOAD']),
+        show_tech_option=dict(type='str', required=False,
+            choices=['STO_BASIC','STO_ALL','STO_BUFFERS','STO_INSTRUMENTATION',
+                'STO_MSTP','STO_OOBM','STO_RAPID_PVST','STO_ROUTE','STO_SMART_LINK',
+                'STO_STATISTICS','STO_TRANSCEIVERS','STO_TUNNEL_INTERCEPT',
+                'STO_TUNNEL_TAP','STO_TUNNEL_VXLAN','STO_COMPONENTS']),
+        boot_image=dict(type='str', required=False, default='BI_PRIMARY_IMAGE',
+            choices=['BI_PRIMARY_IMAGE','BI_SECONDARY_IMAGE']),
+    )
+
+    module_args.update(arubaoss_argument_spec)
+
+    result = dict(changed=False,warnings='Not Supported')
+
+    module = AnsibleModule(
+        argument_spec=module_args,
+        supports_check_mode=True
+    )
+
+    if module.check_mode:
+        module.exit_json(**result)
+    try:
+        result = transfer(module)
+    except Exception as err:
+        return module.fail_json(msg=err)
+
+    module.exit_json(**result)
+
+
+def main():
+    run_module()
+
+if __name__ == '__main__':
+    main()
diff --git a/ansible/modules/network/arubaoss/arubaoss_interface.py b/ansible/modules/network/arubaoss/arubaoss_interface.py
new file mode 100644
index 0000000..47d8f73
--- /dev/null
+++ b/ansible/modules/network/arubaoss/arubaoss_interface.py
@@ -0,0 +1,252 @@
+#!/usr/bin/python
+
+ANSIBLE_METADATA = {
+    'metadata_version': '1.1',
+    'status': ['preview'],
+    'supported_by': 'community'
+}
+
+DOCUMENTATION = '''
+---
+module: arubaoss_interface
+
+short_description: Implements Ansible module for port configuration
+                   and management.
+
+version_added: "2.6"
+
+description:
+    - "This implement rest api's which can be used to configure ports"
+
+options:
+    interface:
+        description:
+            - interface id to be configured
+        required: true
+    description:
+        description:
+            - interface name/description
+        required: false
+    admin_stat:
+        description:
+            - interface admin status
+        required: false
+    qos_policy:
+        description:
+            - Name of QOS policy profile that needs to applied to port
+        required: false
+    acl_id:
+        description:
+            - Name ACL profile that needs to applied to port
+        required: false
+    acl_direction:
+        description:
+            - Direction in which ACL will be applied.
+        required: false
+
+
+author:
+    - Ashish Pant (@hpe)
+'''
+
+EXAMPLES = '''
+     - name: configure port description
+       arubaoss_interface:
+         interface: 1
+         description: "test_interface"
+
+      - name: configure qos on port
+        arubaoss_interface:
+          interface: 5
+          qos_policy: "my_qos"
+
+      - name: delete qos from port
+        arubaoss_interface:
+          interface: 5
+          qos_policy: "my_qos"
+          enable: False
+
+      - name: config acl on ports
+        arubaoss_interface:
+          interface: 2
+          acl_id: test
+          acl_type: standard
+          acl_direction: in
+
+      - name: delete acl ports stats
+        arubaoss_interface:
+          state: delete
+          interface: 2
+          acl_id: test
+          acl_type: standard
+          acl_direction: in
+
+'''
+
+from ansible.module_utils.basic import AnsibleModule
+from ansible.module_utils.network.arubaoss.arubaoss import run_commands,get_config
+from ansible.module_utils.network.arubaoss.arubaoss import arubaoss_argument_spec
+from ansible.module_utils._text import to_text
+
+
+def config_port(module):
+
+    params = module.params
+    url = '/ports/'+  module.params['interface']
+
+    data = {'id': params['interface']}
+
+    if params.get('description') != None:
+        data['name'] =  params['description']
+
+    if params.get('admin_stat') != None:
+        data['is_port_enabled'] = params['admin_stat']
+
+    result = run_commands(module, url, data, 'PUT',check=url)
+
+    return result
+
+
+def qos(module):
+
+    params = module.params
+
+    url = '/qos/ports-policies'
+
+    # check qos policy is present
+    qos_check = '/qos/policies/' + params['qos_policy'] + '~' + 'QPT_QOS'
+    if not get_config(module, qos_check):
+        return {'msg': 'Configure QoS policy first. {} does not exist'.\
+                format(params['qos_policy']),'changed':False}
+
+
+    if params['state'] == 'create':
+        policy_id = params['qos_policy'] + '~' + 'QPT_QOS'
+        port_config = get_config(module, url)
+        if port_config:
+            check_config = module.from_json(to_text(port_config))
+            for ports in check_config['qos_port_policy_element']:
+                if ports['port_id'] == params['interface'] and\
+                   ports['policy_id'] == policy_id:
+                       ret = {'changed':False}
+                       ret.update(ports)
+                       return ret
+
+
+        data = {
+                'port_id': params['interface'],
+                'policy_id': policy_id
+                }
+        result = run_commands(module, url,data, 'POST')
+
+    else:
+        url =  url + '/' + params['interface'] + '-' + params['qos_policy'] + '~' + 'QPT_QOS'
+        check_url = url + '/stats'
+
+        result = run_commands(module, url, {}, 'DELETE', check=check_url)
+
+    return result
+
+
+def acl(module):
+
+    params = module.params
+
+    if params.get('acl_direction') is None:
+        return {'msg': 'Missing parameter: acl_direction','changed':False}
+
+    # Check if acl is present
+    url = "/ports-access-groups"
+    acl_type = params['acl_type']
+    direction = params['acl_direction']
+    data = {'port_id': params['interface'],
+            'acl_id': params['acl_id'] + "~" + acl_type,
+            'direction': direction}
+
+    check_acl = '/acls/' + params['acl_id'] + "~" + acl_type
+    if not get_config(module,check_acl):
+        return {'msg': 'Configure ACL first. {} does not exist'.\
+                                format(params['acl_id']),'changed':False}
+
+    delete_url = url + '/' + params['interface'] + '-' + params['acl_id'] + "~" + acl_type\
+            + '-' +  direction
+
+    config_present = False
+    current_acl = get_config(module,url)
+    if current_acl:
+        check_config = module.from_json(to_text(current_acl))
+
+        for ele in check_config['acl_port_policy_element']:
+            if ele['uri'] == delete_url:
+                config_present = ele
+
+
+    if params['state'] == 'create':
+        if config_present:
+            ret = {'changed': False}
+            ret.update(ele)
+            return ret
+        else:
+            result = run_commands(module, url, data, method='POST')
+    else:
+        if config_present:
+            result = run_commands(module, delete_url, method='DELETE')
+        else:
+            return {'changed': False,'failed': False, 'msg': 'Not present'}
+
+    return result
+
+
+def run_module():
+    module_args = dict(
+        interface=dict(type='str', required=True),
+        description=dict(type='str', required=False),
+        admin_stat=dict(type='bool', required=False),
+        qos_policy=dict(type='str', required=False),
+        state=dict(type='str', required=False, default='create',
+            choices=['create','delete']),
+        acl_id=dict(type='str', required=False),
+        acl_type=dict(type='str', required=False, default='AT_STANDARD_IPV4',
+            choices=['AT_STANDARD_IPV4','AT_EXTENDED_IPV4','AT_CONNECTION_RATE_FILTER']),
+        acl_direction=dict(type='str', required=False, choices=['AD_INBOUND',
+            'AD_OUTBOUND','AD_CRF']),
+    )
+
+    module_args.update(arubaoss_argument_spec)
+
+    result = dict(changed=False,warnings='Not Supported')
+
+    module = AnsibleModule(
+        argument_spec=module_args,
+        supports_check_mode=True
+    )
+
+    if module.check_mode:
+        module.exit_json(**result)
+
+    port_url = '/ports/' + str(module.params['interface'])
+    check_port = get_config(module,port_url)
+    if not check_port:
+        result = {'msg': 'Port {} not present on device {}'.format(module.params['interface'],port_url),
+                'changed':False}
+    else:
+        try:
+
+            if module.params['qos_policy']:
+                result = qos(module)
+            elif module.params['acl_id']:
+                result = acl(module)
+            else:
+                result = config_port(module)
+
+        except Exception as err:
+            return module.fail_json(msg=err)
+
+    module.exit_json(**result)
+
+
+def main():
+    run_module()
+
+if __name__ == '__main__':
+    main()
diff --git a/ansible/modules/network/arubaoss/arubaoss_ip_auth.py b/ansible/modules/network/arubaoss/arubaoss_ip_auth.py
new file mode 100644
index 0000000..56b19ed
--- /dev/null
+++ b/ansible/modules/network/arubaoss/arubaoss_ip_auth.py
@@ -0,0 +1,170 @@
+#!/usr/bin/python
+
+ANSIBLE_METADATA = {
+    'metadata_version': '1.1',
+    'status': ['preview'],
+    'supported_by': 'community'
+}
+
+DOCUMENTATION = '''
+---
+module: arubaoss_ip_auth
+
+short_description: implements rest api for ip authorization
+
+version_added: "2.6"
+
+description:
+    - "This implements rest api's which configure ip autorization on device"
+
+options:
+    auth_ip:
+        description:
+            - Ip address for autherization.
+        required: false
+    access_role:
+        description:
+            - Type of access to be allowed.
+        required: false
+        choices: AR_MANAGER, AR_OPERATOR
+    mask:
+        description:
+            - Net mask for auth_ip.
+        required: false
+    access_method:
+        description:
+            - Type of access method allowed.
+        required: false
+    auth_id:
+        description:
+            - Sequence number for auth rule
+        required: false
+    state:
+        description:
+            - Enable/disable/read ip auth data
+        required: false
+        default: create
+        choices: create, delete
+
+
+author:
+    - Ashish Pant (@hpe)
+'''
+
+EXAMPLES = '''
+      - name: create ip auth all
+        arubaoss_ip_auth:
+          auth_ip: 10.0.12.91
+          mask: 255.255.248.0
+          access_role: AR_MANAGER
+          access_method: AM_ALL
+        register: auth_1
+
+      - name: delete ip auth all
+        arubaoss_ip_auth:
+          auth_ip: 10.0.12.92
+          auth_id: "{{auth_1.id}}"
+          state: delete
+'''
+
+from ansible.module_utils.basic import AnsibleModule
+from ansible.module_utils.network.arubaoss.arubaoss import run_commands,get_config
+from ansible.module_utils.network.arubaoss.arubaoss import arubaoss_argument_spec
+from ansible.module_utils._text import to_text
+
+
+def ip_auth(module):
+
+    params=module.params
+    url = '/ip_auth'
+
+    if params['auth_id']:
+        url = url + '/' + str(params['auth_id'])
+
+    if params['state'] == 'create':
+        if not params['mask'] or not params['auth_ip']:
+            return {'msg': 'Required args: auth_ip, mask','changed':False}
+
+        data = {
+                'auth_ip': {
+                    'octets': params['auth_ip'],
+                    'version': 'IAV_IP_V4'
+                    },
+                'auth_ip_mask': {
+                    'octets': params['mask'],
+                    'version': 'IAV_IP_V4',
+                    },
+                'access_role': params['access_role'],
+                'access_method': params['access_method']
+                }
+
+        if not params['auth_id']:
+            auth_check = get_config(module, url)
+            if auth_check:
+                check_config = module.from_json(to_text(auth_check))
+                total = 0
+                check = 0
+
+                for ele in check_config['ip_auth_element']:
+                    for key in data:
+                        if key in ele:
+                            if ele[key] != data[key]:
+                                check += 1
+                                break
+
+                total = check_config['collection_result']['total_elements_count']
+                print("COUNT",total,check)
+                diff = total - check
+                if (total > 1 and diff == 1) or (total == 1 and check == 0):
+                    return {'msg': 'Ip auth rule already exists.','changed':False}
+
+
+            result = run_commands(module, url, data, 'POST')
+        else:
+            result = run_commands(module, url, data, 'PUT',check=url)
+
+    else:
+        if not params['auth_id']:
+            return {'msg': 'auth_id is required for deletion','changed':False}
+
+        result = run_commands(module, url, {}, 'DELETE',check=url)
+
+    return result
+
+
+def run_module():
+    module_args = dict(
+        state=dict(type='str', required=False, default='create',
+            choices=['create','delete']),
+        auth_ip=dict(type='str', required=False),
+        access_role=dict(type='str', required=False,choices=['AR_MANAGER','AR_OPERATOR']),
+        mask=dict(type='str', required=False),
+        access_method=dict(type='str', required=False,defualt='AM_ALL',
+            choices=['AM_ALL','AM_SSH','AM_TELNET','AM_WEB','AM_SNMP','AM_TFTP']),
+        auth_id=dict(type='int', required=False),
+    )
+
+    module_args.update(arubaoss_argument_spec)
+
+    result = dict(changed=False,warnings='Not Supported')
+
+    module = AnsibleModule(
+        argument_spec=module_args,
+        supports_check_mode=True
+    )
+
+    if module.check_mode:
+        module.exit_json(**result)
+    try:
+        result = ip_auth(module)
+    except Exception as err:
+        return module.fail_json(msg=err)
+
+    module.exit_json(**result)
+
+
+def main():
+    run_module()
+
+if __name__ == '__main__':
+    main()
diff --git a/ansible/modules/network/arubaoss/arubaoss_ip_route.py b/ansible/modules/network/arubaoss/arubaoss_ip_route.py
new file mode 100644
index 0000000..246eb7b
--- /dev/null
+++ b/ansible/modules/network/arubaoss/arubaoss_ip_route.py
@@ -0,0 +1,249 @@
+#!/usr/bin/python
+
+ANSIBLE_METADATA = {
+    'metadata_version': '1.1',
+    'status': ['preview'],
+    'supported_by': 'community'
+}
+
+DOCUMENTATION = '''
+---
+module: any_cli
+
+short_description: implements rest api for static routing
+
+version_added: "2.4"
+
+description:
+    - "This implements static routing rest api and global routing configuration"
+
+options:
+    ip_route_mode:
+        description:
+            - Mode for route type
+        choices: 'IRM_GATEWAY','IRM_REJECT','IRM_VLAN','IRM_BLACK_HOLE','IRM_TUNNEL_ARUBA_VPN'
+        required: true
+    destination_vlan:
+        description:
+            - vlan id for IRM_VLAN mode.
+        required: false
+    metric:
+        description:
+            - ip route metric
+        default= 1
+        required: false
+    distance:
+        description:
+            - ip route distance
+        defualt: 1
+        required: false
+    name:
+        description:
+            - name for ip route being configured
+        required: false
+    tag:
+        description:
+            - Tag that can be used to filter redistribution of this route via route-maps
+        required: false
+    logging:
+        description:
+            - if the packets received on the route need to be logged
+        required: false
+    ip_version:
+        description:
+            - Ip address type to be configured
+        defualt: IAV_IPV_V4
+        required: false
+    gateway:
+        description:
+            - IP address of the gateway to forward traffic when route mode is IRM_GATEWAY
+        required: false
+    mask:
+        description:
+            - Subnet for the ip route.
+        required: false
+    destination:
+        description:
+            - IP address for the ip routed
+        required: false
+    bfd_ip_address:
+        description:
+            - Enable BFD for static routes. Only for Lava and Bolt platforms.
+        required: false
+    vlan_name:
+        description:
+            - vlan id/name to which route is being applied
+        required: false
+
+
+author:
+    - Ashish Pant (@hpe)
+'''
+
+EXAMPLES = '''
+     - name: add route vlan
+       arubaoss_ip_route:
+         ip_route_mode: IRM_VLAN
+         ip_version: IAV_IP_V4
+         destination: 1.1.1.0
+         mask: 255.255.255.0
+         destination_vlan: 20
+         name: "test"
+
+     - name: add route vlan
+       arubaoss_ip_route:
+         ip_route_mode: IRM_VLAN
+         ip_version: IAV_IP_V4
+         destination: 1.1.1.0
+         mask: 255.255.255.0
+         destination_vlan: 20
+         name: "test"
+
+
+     - name: add route blackhole
+       arubaoss_ip_route:
+         ip_route_mode: IRM_BLACK_HOLE
+         ip_version: IAV_IP_V4
+         destination: 2.2.2.0
+         mask: 255.255.255.0
+
+     - name: delete route vlan
+       arubaoss_ip_route:
+         ip_route_mode: IRM_VLAN
+         destination_vlan: 20
+         destination: 1.1.1.0
+         mask: 255.255.255.0
+         state: delete
+
+     - name: delete route blackhole
+       arubaoss_ip_route:
+         ip_route_mode: IRM_BLACK_HOLE
+         destination: 2.2.2.0
+         mask: 255.255.255.0
+         state: delete
+
+     - name: delete route blackhole
+       arubaoss_ip_route:
+         ip_route_mode: IRM_BLACK_HOLE
+         destination: 2.2.2.0
+         mask: 255.255.255.0
+         state: delete
+
+'''
+
+from ansible.module_utils.basic import AnsibleModule
+from ansible.module_utils.network.arubaoss.arubaoss import run_commands,get_config
+from ansible.module_utils.network.arubaoss.arubaoss import arubaoss_argument_spec
+from ansible.module_utils._text import to_text
+
+
+def route(module):
+
+    params = module.params
+    url = "/ip-route"
+
+    route_type = params['ip_route_mode']
+    if route_type == 'IRM_VLAN':
+        for key in ['destination_vlan','vlan_name']:
+            if key not in params:
+                return {'msg': '{} is required for {}'.format(key,route_type),
+                        'changed': False}
+
+    if route_type == 'IRM_GATEWAY':
+        if 'gateway' not in params:
+            return {'msg': 'gateway is required for {}'.format(route_type),
+                    'changed': False}
+        else:
+            if params['gateway']:
+                data['gateway'] = {'version': params['ip_version'],
+                        'octects': params['mask']                                                                                      }
+
+    data = {'ip_route_mode': params['ip_route_mode'],
+            'metric': params['metric'],
+            'distance': params['distance']
+            }
+
+    for key in ['destination','mask','bfd_ip_address']:
+        if params[key]:
+            data[key] = {}
+            data[key]['version'] = params['ip_version']
+            data[key]['octets'] = params[key]
+
+
+    if params['tag']:
+        data['tag'] = params['tag']
+
+    if params['logging'] and route_type == 'IRM_BLACK_HOLE':
+        data['logging'] = params['logging']
+
+    check_url = url + "/" + params['destination'] + "-" + params['mask'] + "-" +\
+            params['ip_route_mode']
+
+    if params['destination_vlan']:
+        vlan_url = '/vlans/' + str(params['destination_vlan'])
+        check_vlan = get_config(module,vlan_url)
+        if not check_vlan:
+            return {'msg': 'Vlan {} not configured'.format(params['destination_vlan']),
+                    'changed':False}
+
+
+        data['id'] = params['destination'] + "-" +params['mask'] + "-" +\
+                params['ip_route_mode'] + "-" + str(params['destination_vlan'])
+
+        data['destination_vlan'] = {'vlan_id':params['destination_vlan'],
+                                    'vlan_name': params['vlan_name']
+                                    }
+
+        check_url = check_url + '-' + str(params['destination_vlan'])
+
+    if params['state'] == 'create':
+        result = run_commands(module, url, data, 'POST',check=check_url)
+    else:
+        result = run_commands(module, check_url, {}, 'DELETE',check=check_url)
+
+    return result
+
+
+def run_module():
+    module_args = dict(
+        state=dict(type='str', required=False, default='create',
+            choices=['create','delete']),
+        ip_route_mode=dict(type='str', required=True, choices=['IRM_GATEWAY',
+            'IRM_REJECT','IRM_VLAN','IRM_BLACK_HOLE','IRM_TUNNEL_ARUBA_VPN']),
+        destination_vlan=dict(type='int', required=False,default=False),
+        metric=dict(type='int', required=False,default=1),
+        distance=dict(type='int', required=False,default=1),
+        name=dict(type='str', required=False,default=''),
+        tag=dict(type='int', required=False,default=0),
+        logging=dict(type='bool', required=False,default=False),
+        ip_version=dict(type='str', required=False, default='IAV_IP_V4'),
+        gateway=dict(type='str', required=False,default=''),
+        mask=dict(type='str', required=True),
+        destination=dict(type='str', required=True),
+        bfd_ip_address=dict(type='str', required=False,default=''),
+        vlan_name=dict(type='str', required=False, default=""),
+    )
+
+    module_args.update(arubaoss_argument_spec)
+
+    result = dict(changed=False,warnings='Not Supported')
+
+    module = AnsibleModule(
+        argument_spec=module_args,
+        supports_check_mode=True
+    )
+
+    if module.check_mode:
+        module.exit_json(**result)
+    try:
+        result = route(module)
+    except Exception as err:
+        return module.fail_json(msg=err)
+
+    module.exit_json(**result)
+
+def main():
+    run_module()
+
+if __name__ == '__main__':
+    main()
diff --git a/ansible/modules/network/arubaoss/arubaoss_loop_protect.py b/ansible/modules/network/arubaoss/arubaoss_loop_protect.py
new file mode 100644
index 0000000..c54b620
--- /dev/null
+++ b/ansible/modules/network/arubaoss/arubaoss_loop_protect.py
@@ -0,0 +1,205 @@
+#!/usr/bin/python
+
+ANSIBLE_METADATA = {
+    'metadata_version': '1.1',
+    'status': ['preview'],
+    'supported_by': 'community'
+}
+
+DOCUMENTATION = '''
+---
+module: loop_protect
+
+short_description: implements loop-protect rest api
+
+version_added: "2.6"
+
+description:
+    - "This configures loop protect on device over vlan or port"
+
+options:
+    command:
+        description:
+            - Type of action to be taken.
+        required: true
+    port_disable_timer:
+        description:
+            - Set the number of seconds before disabled ports are
+              automatically re-enabled
+        required: false
+    trasmit_interval:
+        description:
+            - Set the number of seconds between loop detect packet transmissions.
+        required: false
+    mode:
+        description:
+            - Configures vlan or port mode
+        required: false
+        default: LPM_PORT
+        choices: LPM_PORT, LPM_VLAN
+    interface:
+        description:
+            - Interface id on which loop protect to be configured
+        required: false
+    receiver_action:
+        description:
+            - Set the action to take when a loop is detected.
+              is_loop_protection_enabled must be true to update the receiver_action.
+        required: false
+        default: LPRA_SEND_DISABLE
+        choices: LPRA_SEND_DISABLE, LPRA_NO_DISABLE, LPRA_SEND_RECV_DISABLE
+    vlan:
+        description:
+            - Vlan id on which loop protect is to be configured
+        required: false
+
+
+extends_documentation_fragment:
+    - azure
+
+author:
+    - Ashish Pant (@hpe)
+'''
+
+EXAMPLES = '''
+     - name: update loop
+       arubaoss_loop_protect:
+         command: update
+         trap: True
+
+     - name: enable loop-prtoect on port
+       arubaoss_loop_protect:
+         command: update_port
+         interface: 1
+
+     - name: disable loop-prtoect on port
+       arubaoss_loop_protect:
+         command: update_port
+         interface: 1
+         loop_protected: False
+
+     - name: change loop-protect mode to vlan
+       arubaoss_loop_protect:
+         command: update
+         mode: LPM_VLAN
+
+     - name: enable loop-prtoect on vlan
+       arubaoss_loop_protect:
+         command: update_vlan
+         vlan: 10
+
+'''
+
+
+from ansible.module_utils.basic import AnsibleModule
+from ansible.module_utils.network.arubaoss.arubaoss import run_commands,get_config
+from ansible.module_utils.network.arubaoss.arubaoss import arubaoss_argument_spec
+import sys
+
+
+def update(module):
+
+    params = module.params
+    url = "/loop_protect"
+
+    data = {
+            'port_disable_timer_in_senconds': params['port_disable_timer'],
+            'trasmit_interval_in_seconds': params['transmit_interval'],
+            'mode': params['mode'],
+            'is_trap_on_loop_detected_enabled': params['trap']
+            }
+
+    result = run_commands(module, url, data, 'PUT',check=url)
+
+    return result
+
+
+def update_port(module):
+
+    params = module.params
+    url = '/loop_protect/ports/' +  params['interface']
+    port_url = '/ports/' + str(params['interface'])
+    check_port = get_config(module,port_url)
+    if not check_port:
+        return {'msg': 'Port {} not present on device'.format(params['interface']),
+                'changed':False}
+
+
+    data = {
+            'port_id': params['interface'],
+            'is_loop_protection_enabled': params['loop_protected'],
+            'receiver_action': params['receiver_action']
+            }
+
+    result = run_commands(module, url, data, 'PUT',check=url)
+
+    return result
+
+
+def update_vlan(module):
+
+    params = module.params
+    url = '/loop_protect/vlans/' +  str(params['vlan'])
+    vlan_url = '/vlans/' + str(params['vlan'])
+    check_vlan = get_config(module,vlan_url)
+    if not check_vlan:
+        return {'msg': 'Vlan {} not configured'.format(params['vlan']),
+                'changed':False}
+
+
+    data = {
+            'vlan_id': params['vlan'],
+            'is_vlan_loop_protected': params['loop_protected'],
+            }
+
+    result = run_commands(module, url, data, 'PUT',check=url)
+
+    return result
+
+
+def run_module():
+    module_args = dict(
+        command=dict(type='str', required=True,
+            choices=['update','update_port','update_vlan']),
+        port_disable_timer=dict(type='int', required=False, default=0),
+        transmit_interval=dict(type='int', required=False, default=5),
+        mode=dict(type='str', required=False, choices=['LPM_PORT','LPM_VLAN'],
+            default='LPM_PORT'),
+        trap=dict(type='bool', required=False, default=False),
+        interface=dict(type='str', required=False,),
+        loop_protected=dict(type='bool', required=False, default=True),
+        receiver_action=dict(type='str', required=False, default='LPRA_SEND_DISABLE',
+            choices=['LPRA_SEND_DISABLE','LPRA_NO_DISABLE','LPRA_SEND_RECV_DISABLE']),
+        vlan=dict(type='int', required=False),
+    )
+
+    module_args.update(arubaoss_argument_spec)
+
+    result = dict(changed=False,warnings='Not Supported')
+
+    module = AnsibleModule(
+        argument_spec=module_args,
+        supports_check_mode=True
+    )
+
+    if module.check_mode:
+        module.exit_json(**result)
+
+    command = module.params['command']
+
+    try:
+        thismod = sys.modules[__name__]
+        method = getattr(thismod, command)
+
+        result = method(module)
+    except Exception as err:
+        return module.fail_json(msg=err)
+
+    module.exit_json(**result)
+
+
+def main():
+    run_module()
+
+if __name__ == '__main__':
+    main()
diff --git a/ansible/modules/network/arubaoss/arubaoss_macAuthentication.py b/ansible/modules/network/arubaoss/arubaoss_macAuthentication.py
new file mode 100644
index 0000000..0ef6383
--- /dev/null
+++ b/ansible/modules/network/arubaoss/arubaoss_macAuthentication.py
@@ -0,0 +1,181 @@
+#!/usr/bin/python
+
+ANSIBLE_METADATA = {
+    'metadata_version': '1.1',
+    'status': ['preview'],
+    'supported_by': 'community'
+}
+
+DOCUMENTATION = '''
+---
+module: arubaoss_macAuthentication
+
+short_description: implements rest api for Mac Authentication
+
+version_added: "2.4"
+
+description:
+    - "This implements rest apis which can be used to configure Mac Authentication"
+
+options:
+    command:
+        description: The command to be configured
+        required: False
+        choices: configMacAuth, configMacAuthOnPort
+    port_id:
+        description: The port id to be configured on the switch
+        required: False
+    unauthorized_vlan_id:
+        description: Unauthorized VLAN ID. If we are giving unauthorized_vlan_id as 0,
+                     it will remove the unauthorized_vlan_id configured
+        required: False
+    is_mac_authentication_enabled:
+        description: Enables/disables MAC authentication on the Port
+        required: False
+    reauthenticate
+        description: Provides option on whether to reauthenticate
+        required: False
+    mac_address_limit:
+        description: The MAC Authentication address limit to be configured
+        required: False
+
+author:
+    - Sanju Sadanandan (@hpe)
+'''
+
+EXAMPLES = '''
+    - name: Updates Mac Authentication globally
+      arubaoss_macAuthentication:
+        command: "configMacAuth"
+        unauthorized_vlan_id: 10
+
+'''
+
+
+from ansible.module_utils.basic import AnsibleModule
+from ansible.module_utils.network.arubaoss.arubaoss import run_commands
+from ansible.module_utils.network.arubaoss.arubaoss import arubaoss_argument_spec
+from ansible.module_utils.network.arubaoss.arubaoss import get_config
+"""
+-------
+Name: config
+
+Configures mac authentication globally on the switch
+
+param request: module
+
+Returns
+ Configure the switch with params sent
+-------
+"""
+def configMacAuthOnPort(module):
+
+    params = module.params
+    data = {}
+
+    if params['port_id'] == "":
+        return {'msg': "Port Id cannot be null",
+                'changed': False, 'failed': False}
+    else:
+        data['port_id'] = params['port_id']
+
+    data['reauthenticate'] = params['reauthenticate']
+    data['mac_address_limit'] = params['mac_address_limit']
+    data['is_mac_authentication_enabled'] = params['is_mac_authentication_enabled']
+
+    # Verify if the vlans are already present
+    if params['unauthorized_vlan_id']:
+        check_presence = get_config(module, "/vlans/"+ str(params['unauthorized_vlan_id']))
+        if not check_presence:
+            return {'msg': 'Cannot unauthorize the vlan without Vlan configured',
+                'changed': False, 'failed': False}
+        else:
+            data['unauthorized_vlan_id'] = params['unauthorized_vlan_id']
+
+    url = '/mac-authentication/port/' + str(params['port_id'])
+
+    method = 'PUT'
+
+    result = run_commands(module, url, data, method, check=url)
+    return result
+
+"""
+-------
+Name: config
+
+Configures mac authentication globally on the switch
+
+param request: module
+
+Returns
+ Configure the switch with params sent
+-------
+"""
+def configMacAuth(module):
+
+    params = module.params
+    data = {}
+
+    # Verify if the vlans are already present
+    if params['unauthorized_vlan_id']:
+        check_presence = get_config(module, "/vlans/"+ str(params['unauthorized_vlan_id']))
+        if not check_presence:
+            return {'msg': 'Cannot unauthorize the vlan without Vlan configured',
+                'changed': False, 'failed': False}
+        else:
+            data['unauthorized_vlan_id'] = params['unauthorized_vlan_id']
+    data['is_mac_authentication_enabled'] = params['is_mac_authentication_enabled']
+
+    url = '/mac-authentication'
+    method = 'PUT'
+
+    result = run_commands(module, url, data, method, check=url)
+    return result
+"""
+-------
+Name: run_module()
+
+The main module invoked
+
+Returns
+ Configure the switch with params sent
+-------
+"""
+def run_module():
+    module_args = dict(
+        command=dict(type='str',required=False, default="configMacAuth",
+              choices=["configMacAuth", "configMacAuthOnPort"]),
+        unauthorized_vlan_id=dict(type='int', required=False, default=0),
+        port_id=dict(type='str',required=False, default=""),
+        is_mac_authentication_enabled=dict(type='bool', required=False, default=True),
+        mac_address_limit=dict(type='int', required=False, default=1),
+        reauthenticate=dict(type='bool', required=False, default=False),
+    )
+
+    module_args.update(arubaoss_argument_spec)
+
+    result = dict(changed=False,warnings='Not Supported')
+
+    module = AnsibleModule(
+        argument_spec=module_args,
+        supports_check_mode=True
+    )
+
+    if module.check_mode:
+        module.exit_json(**result)
+
+    try:
+        if module.params['command'] == "configMacAuth":
+            result = configMacAuth(module)
+        else:
+            result = configMacAuthOnPort(module)
+    except Exception as err:
+        return module.fail_json(msg=err)
+
+    module.exit_json(**result)
+
+def main():
+    run_module()
+
+if __name__ == '__main__':
+    main()
diff --git a/ansible/modules/network/arubaoss/arubaoss_ntp.py b/ansible/modules/network/arubaoss/arubaoss_ntp.py
new file mode 100644
index 0000000..cfe7ad9
--- /dev/null
+++ b/ansible/modules/network/arubaoss/arubaoss_ntp.py
@@ -0,0 +1,456 @@
+#!/usr/bin/python
+
+ANSIBLE_METADATA = {
+    'metadata_version': '1.1',
+    'status': ['preview'],
+    'supported_by': 'community'
+}
+
+DOCUMENTATION = '''
+---
+module: arubaoss_ntp
+
+short_description: implements rest api for NTP configuration
+
+version_added: "2.4"
+
+description:
+    - "This implements rest apis which can be used to configure NTP"
+
+options:
+    command:
+        description: To config or unconfig the required command
+        choices: config_timesync, enable_includeCredentials, config_ntp,
+                 config_ntp_keyId, config_ntp_ipv4addr
+        required: False
+    ntp_ip4addr:
+        description: The IPv4 address of the server
+        required: False
+    minpoll_value:
+        description: Configures the minimum time interval in seconds
+        required: False
+    maxpoll_value:
+        description: Configures the maximum time interval in seconds
+        required: False
+    burst:
+        description: Enables burst mode
+        required: False
+    iburst:
+        description: Enables initial burst mode
+        required: False
+    keyId:
+        description: Sets the authentication key to use for this server
+        required: False
+    timesyncType:
+        description: Updates the timesync type, takes values: ntp, sntp, timep
+                     and timep-or-sntp
+        required: False
+    include_credentials_in_response:
+        description: Enables include credentials when value is set to ICS_ENABLED
+        choices: ICS_ENABLED, ICS_DISABLED, ICS_RADIUS_TACAS_ONLY
+        required: False
+    broadcast:
+        description: Operate in broadcast mode
+        required: False
+    association_value:
+        description: Maximum number of NTP associations
+        required: False
+    trap_value:
+        description: Sets trap type
+        required: False
+    keyValue:
+        description: The string to be added to authentication KeyId
+        required: False
+
+author:
+    - Sanju Sadanandan (@hpe)
+'''
+
+EXAMPLES = '''
+     - name: Updates the  system with NTP Server configuration
+       arubaoss_ntp:
+         command: "config_ntp_ipv4addr"
+         config: "create"
+         ntp_ip4addr: "10.20.40.33"
+         keyId: 2
+         burst: True
+         iburst: True
+'''
+
+from ansible.module_utils.basic import AnsibleModule
+from ansible.module_utils.network.arubaoss.arubaoss import run_commands
+from ansible.module_utils.network.arubaoss.arubaoss import arubaoss_argument_spec
+from ansible.module_utils.network.arubaoss.arubaoss import get_config
+import json
+
+"""
+-------
+Name: config_timesync
+
+Configures timesync
+
+param request: module
+
+Returns
+ Configure the switch with params sent
+-------
+"""
+def config_timesync(module):
+
+    params = module.params
+    data = {}
+
+    # Parameters
+    timesyncType = params['timesyncType']
+
+    data[timesyncType] = True
+
+    # URI
+    url = "/config/timesync"
+    method = "PUT"
+
+    # Check if timesync is set already
+    check_presence = get_config(module, "/config/timesync")
+    newdata = json.loads(check_presence)
+    if timesyncType == 'ntp' and 'ntp' in newdata:
+        return {'msg': 'timesync already set to NTP',
+                'changed': False, 'failed': False}
+    elif timesyncType == 'timep' and 'timep' in newdata:
+        return {'msg': 'timesync already set to Timep',
+                'changed': False, 'failed': False}
+    elif timesyncType == 'sntp' and 'sntp' in newdata:
+        return {'msg': 'timesync already set to SNTP',
+                'changed': False, 'failed': False}
+    elif timesyncType == 'timep-or-sntp'  and 'timep-or-sntp' in newdata:
+        return {'msg': 'timesync already set to timep or SNTP',
+                'changed': False, 'failed': False}
+    else:
+        # Config
+        result = run_commands(module, url, data, method)
+        return result
+"""
+------
+Name: enable_includeCredentials
+
+Enabled Include Credentials on switch
+
+param request: module
+
+Returns
+ Configure the switch with params sent
+-------
+"""
+def enable_includeCredentials(module):
+
+    params = module.params
+    data = {}
+
+    # Parameters
+    data['include_credentials_in_response'] = params['include_credentials_in_response']
+
+    # URI
+    url = "/system/include-credentials"
+    method = "PUT"
+
+    # Config
+    result = run_commands(module, url, data, method, check=url)
+    return result
+
+"""
+-------
+Name: config_ntp
+
+Configures NTP Service  on switch
+
+param request: module
+
+Returns
+ Configure the switch with params sent
+-------
+"""
+def config_ntp(module):
+
+    params = module.params
+    data = {}
+
+    # Check if timesync is set to NTP
+    check_presence = get_config(module, "/config/timesync")
+    newdata = json.loads(check_presence)
+    if not 'ntp' in newdata:
+        return {'msg': 'timesync should be set to NTP',
+                'changed': False, 'failed': False}
+
+    # Parameters
+    data['broadcast'] = params['broadcast']
+    #data['unicast'] = params['unicast']
+
+    #data['max-association'] = {'cmd_no_form': params['cmd_no_form'],
+    #            'max-association_value': params['association_value']}
+    data['max-association'] = {'max-association_value': params['association_value']}
+
+    if params['config'] == "create":
+        data['enable'] = True
+    else:
+        data['enable'] = False
+
+    if params['trap_cmd_no_form'] == "True" and params['trap_value'] == "":
+        return {'msg': 'trap-value cannot be null',
+                'changed': False, 'failed': False}
+    else:
+        #data['trap'] = [{'cmd_no_form': params['trap_cmd_no_form'], \
+        #        'trap_value': params['trap_value']}]
+        data['trap'] = [{'trap_value': params['trap_value']}]
+
+    # URI
+    url = "/config/ntp"
+    method = "PUT"
+
+    # Config
+    result = run_commands(module, url, data, method, check=url)
+    return result
+
+"""
+-------
+Name: config_ntp_keyId
+
+Configures NTP Server with Key Id
+
+param request: module
+
+Returns
+ Configure the switch with params sent
+-------
+"""
+def config_ntp_keyId(module):
+
+    params = module.params
+    data = {}
+
+    # Verify ntp is enabled
+    check_presence = get_config(module, "/config/ntp")
+    if not check_presence:
+        return {'msg': 'NTP should be enabled',
+                'changed': False, 'failed': False}
+
+    # Verify include credentials is enabled
+    check_presence = get_config(module, "/system/include-credentials")
+    if not check_presence:
+        return {'msg': 'Include Credentials should be enabled',
+                'changed': False, 'failed': False}
+
+    # URI
+    check_url = "/config/ntp/authentication/key-id/int/" + str(params['keyId'])
+    url = "/config/ntp/authentication/key-id/int"
+
+    # Verify if key is already a trusted entry
+    check_presence = get_config(module, check_url)
+    if check_presence:
+        newdata = json.loads(check_presence)
+        if newdata['int']['int_reference']['authentication-mode']['md5']:
+            if newdata['int']['int_reference']['authentication-mode']['md5']['key-value']['key']['key_reference']['trusted'] == True:
+                return {'msg': 'Key is already a trusted entry',
+                    'changed': False, 'failed': False}
+        if newdata['int']['int_reference']['authentication-mode']['sha1']:
+            if newdata['int']['int_reference']['authentication-mode']['sha1']['key-value']['key']['key_reference']['trusted'] == True:
+                return {'msg': 'Key is already a trusted entry',
+                    'changed': False, 'failed': False}
+
+    # Parameters
+    data["int"] = {
+        "int_reference": {
+            "authentication-mode": {
+                params['authenticationMode']: {
+                    "key-value": {
+                        "key": {
+                            "key_reference": {
+                                "trusted": params['trusted']
+                            },
+                            "key_value": params['keyValue']
+                        }
+                    }
+                }
+            }
+        },
+        "int_value": params['keyId']}
+
+    # Config
+    if params['config'] == "create":
+        # check if already present
+        check_presence = get_config(module, check_url)
+        if not check_presence:
+            method = "POST"
+        else:
+            url = check_url
+            method = "PUT"
+    else:
+        url = check_url
+        method = "DELETE"
+
+    result = run_commands(module, url, data, method, check=check_url)
+    return result
+
+"""
+-------
+Name: config_ntp_ipv4addr
+
+Configures NTP Server of IPv4 address on switch
+
+param request: module
+
+Returns
+ Configure the switch with params sent
+-------
+"""
+def config_ntp_ipv4addr(module):
+
+    params = module.params
+
+    # Verify ntp is enabled
+    check_presence = get_config(module, "/config/ntp")
+    if not check_presence:
+        return {'msg': 'NTP should be enabled',
+                'changed': False, 'failed': False}
+
+    # Verify the key is trusted
+    check_presence = get_config(module, "/config/ntp/authentication/key-id/int/" + str(params['keyId']))
+    if check_presence:
+        newdata = json.loads(check_presence)
+        if newdata['int']['int_reference']['authentication-mode']['md5']:
+            if newdata['int']['int_reference']['authentication-mode']['md5']['key-value']['key']['key_reference']['trusted'] == True:
+                return {'msg': 'Key is already a trusted entry',
+                    'changed': False, 'failed': False}
+        if newdata['int']['int_reference']['authentication-mode']['sha1']:
+            if newdata['int']['int_reference']['authentication-mode']['sha1']['key-value']['key']['key_reference']['trusted'] == True:
+                return {'msg': 'Key is already a trusted entry',
+                    'changed': False, 'failed': False}
+
+    # Parameters
+    data = {}
+    if params['ntp_ip4addr'] is "":
+        return {'msg': 'IP Address cannot be null',
+                'changed': False, 'failed': False}
+    else:
+        data['ip4addr'] = {
+                      'ip4addr_reference': {
+                         'max-poll': {'max-poll_value': params['maxpoll_value']},
+                         'min-poll': {'min-poll_value': params['minpoll_value']},
+                                           },
+                      'ip4addr_value': params['ntp_ip4addr']
+                      }
+
+    if params['keyId'] is not 0:
+
+        keyVal = {}
+        keyVal = {'key-id': {'key-id_value': params['keyId']}}
+        data['ip4addr']['ip4addr_reference'].update(keyVal)
+
+    # Sanju: Changed from "" to False
+    if params['iburst'] is True:
+        iburst = {}
+        iburst = {'iburst' :  params['iburst']}
+        data['ip4addr']['ip4addr_reference'].update(iburst)
+
+    # ISSUE: These values throw error: Error: JSON OneOf validation failed: 'burst'
+    #if params['burst'] is True:
+    #    burst = {}
+    #    burst = {'burst' :  params['burst']}
+    #    data['ip4addr']['ip4addr_reference'].update(burst)
+
+    # URIs
+    url = "/config/ntp/server/ip4addr"
+    check_url = "/config/ntp/server/ip4addr/" + str(params['ntp_ip4addr'])
+
+    # Config
+    if params['config'] == "create":
+
+        # Check if a server ip is already configured
+        check_presence = get_config(module, check_url)
+        if not check_presence:
+            method = 'POST'
+        else:
+            method = 'PUT'
+            url = check_url
+
+    elif params['config'] == "delete":
+        url = check_url
+        method = 'DELETE'
+    else:
+        return {'msg': 'Valid config options are : create and delete',
+                'changed': False, 'failed': False}
+
+    result = run_commands(module, url, data, method, check=check_url)
+    return result
+
+"""
+-------
+Name: run_module()
+
+The main module invoked
+
+Returns
+ Configure the switch with params sent
+-------
+"""
+def run_module():
+    module_args = dict(
+        command=dict(type='str', required=False, default="config_ntp",
+            choices=["config_timesync", "enable_includeCredentials", "config_ntp", "config_ntp_keyId", "config_ntp_ipv4addr"]),
+        config=dict(type='str', required=False, default="create",
+            choices=["create", "delete"]),
+        sntp=dict(type='bool', required=False, default=False),
+        timep=dict(type='bool', required=False, default=False),
+        timepOrSntp=dict(type='bool', required=False, default=False),
+        timesyncType=dict(type='str', required=False, default="ntp",
+            choices=["ntp", "sntp", "timep", "timep-or-sntp"]),
+        broadcast=dict(type='bool', required=False, default=True),
+        unicast=dict(type='bool', required=False, default=False),
+        cmd_no_form=dict(type='bool', required=False, default=False),
+        association_value=dict(type='int', required=False, default=8),
+        trap_cmd_no_form=dict(type='bool', required=False, default=False),
+        trap_value=dict(type='str', required=False, default=""),
+        ntp_ip4addr=dict(type='str', required=False, default=""),
+        maxpoll_value=dict(type='int', required=False, default=10),
+        minpoll_value=dict(type='int', required=False, default=6),
+        burst=dict(type='bool', required=False, default=False),
+        iburst=dict(type='bool', required=False, default=False),
+        include_credentials_in_response=dict(type='str', required=False, default="ICS_ENABLED",
+           choices = ['ICS_ENABLED','ICS_DISABLED','ICS_RADIUS_TACAS_ONLY']),
+        keyId=dict(type='int', required=False, default=1),
+        trusted=dict(type='bool', required=False, default=True),
+        keyValue=dict(type='str', required=False, default=""),
+        authenticationMode=dict(type='str', required=False, default="md5"),
+    )
+
+    module_args.update(arubaoss_argument_spec)
+
+    result = dict(changed=False)
+
+    module = AnsibleModule(
+        argument_spec=module_args,
+        supports_check_mode=True
+    )
+
+    if module.check_mode:
+        module.exit_json(**result)
+
+    try:
+        if module.params['command'] == "config_timesync":
+            result = config_timesync(module)
+        elif module.params['command'] == "enable_includeCredentials":
+            result = enable_includeCredentials(module)
+        elif module.params['command'] == "config_ntp":
+            result = config_ntp(module)
+        elif module.params['command'] == "config_ntp_ipv4addr":
+            result = config_ntp_ipv4addr(module)
+        else:
+            result = config_ntp_keyId(module)
+    except Exception as err:
+        return module.fail_json(msg=err)
+
+    module.exit_json(**result)
+
+def main():
+    run_module()
+
+if __name__ == '__main__':
+    main()
diff --git a/ansible/modules/network/arubaoss/arubaoss_poe.py b/ansible/modules/network/arubaoss/arubaoss_poe.py
new file mode 100644
index 0000000..fb40f44
--- /dev/null
+++ b/ansible/modules/network/arubaoss/arubaoss_poe.py
@@ -0,0 +1,258 @@
+#!/usr/bin/python
+
+ANSIBLE_METADATA = {
+    'metadata_version': '1.1',
+    'status': ['preview'],
+    'supported_by': 'community'
+}
+
+DOCUMENTATION = '''
+---
+module: arubaoss_poe
+
+short_description: implements rest api for PoE configuration
+
+version_added: "2.4"
+
+description:
+    - "This implements rest apis which can be used to configure PoE"
+
+options:
+    command:
+        description: The module to be called.
+        choices: reset_poe_port, config_poe_port and config_poe_slot
+        required: False
+    port_id:
+        description: The Port id
+        required: False
+    is_poe_enabled:
+        description: The port PoE status
+        required: False
+    poe_priority:
+        description: The port PoE priority
+        choices: PPP_CRITICAL, PPP_HIGH, PPP_LOW
+        required: False
+    poe_allocation_method:
+        description: The PoE allocation method
+        choices: PPAM_USAGE, PPAM_CLASS, PPAM_VALUE
+        required: False
+    allocated_power_in_watts:
+        description: Allocated power value. Default value for this is
+                     platform dependent
+        required: False
+    port_configured_type:
+        description:  Port configured type
+        required: False
+    pre_standard_detect_enabled:
+        description: pre_std_detect enable or disable
+        required: False
+    slot_name:
+        description: The slot name
+        required: False
+    power_threshold_percentage:
+        description: The power threshold percentage
+        required: False
+
+author:
+    - Sanju Sadanandan (@hpe)
+'''
+
+EXAMPLES = '''
+     - name: Updates poe port
+       arubaoss_poe:
+         command: config_poe_port
+         port_id: 2
+         is_poe_enabled: True
+         poe_priority: "PPP_HIGH"
+         poe_allocation_method: "PPAM_VALUE"
+         allocated_power_in_watts: 15
+         port_configured_type: ""
+         pre_standard_detect_enabled: False
+
+'''
+
+from ansible.module_utils.basic import AnsibleModule
+from ansible.module_utils.network.arubaoss.arubaoss import run_commands
+from ansible.module_utils.network.arubaoss.arubaoss import arubaoss_argument_spec
+from ansible.module_utils.network.arubaoss.arubaoss import get_config
+import json
+
+"""
+-------
+Name: config
+
+Resets the PoE controller to which the port belongs
+
+param request: module
+
+Returns
+ Configure the switch with params sent
+-------
+"""
+def reset_poe_port(module):
+
+    params = module.params
+    data = {}
+
+    # Check if port_id is null
+    if params['port_id'] == "":
+        return {'msg': 'port_id cannot be null',
+                'changed': False, 'failed': False}
+
+    url = '/poe/ports/' + str(params['port_id']) + '/reset'
+    method = 'POST'
+
+    result = run_commands(module, url, data, method, check=url)
+
+    return result
+"""
+-------
+Name: config
+
+Resets the PoE controller to which the port belongs
+
+param request: module
+
+Returns
+ Configure the switch with params sent
+-------
+"""
+def config_poe_port(module):
+
+    params = module.params
+    data = {}
+
+    data['port_id'] = params['port_id']
+    data['is_poe_enabled'] = params['is_poe_enabled']
+    data['poe_priority'] = params['poe_priority']
+    data['poe_allocation_method'] = params['poe_allocation_method']
+    data['port_configured_type'] = params['port_configured_type']
+    data['pre_standard_detect_enabled'] = params['pre_standard_detect_enabled']
+
+    # allocated_power_in_watts can be set only when poe_allocation_method is PPAM_VALUE
+    if params['poe_allocation_method'] == "PPAM_VALUE":
+        data['allocated_power_in_watts'] = params['allocated_power_in_watts']
+
+    # Check if port_id is null
+    if params['port_id'] == "":
+        return {'msg': 'port_id cannot be null',
+                'changed': False, 'failed': False}
+
+    url = '/ports/' + str(params['port_id']) + '/poe'
+    method = 'PUT'
+
+    diffSeen = False
+    check_presence = get_config(module, url)
+    newdata = json.loads(check_presence)
+    for key in data:
+        if not newdata[key] == data[key]:
+            diffSeen = True
+            break
+
+    if diffSeen:
+        result = run_commands(module, url, data, method, check=url)
+        return result
+    else:
+        return {'msg': 'Already Configured',
+                'changed': False, 'failed': False}
+
+"""
+-------
+Name: config
+
+Resets the PoE controller to which the port belongs
+
+param request: module
+
+Returns
+ Configure the switch with params sent
+-------
+"""
+def config_poe_slot(module):
+
+    params = module.params
+    data = {}
+
+    data['slot_name'] = params['slot_name']
+    data['power_threshold_percentage'] = params['power_threshold_percentage']
+
+    # Check if slot_name is null
+    if params['slot_name'] == "":
+        return {'msg': 'slot_name cannot be null',
+                'changed': False, 'failed': False}
+
+    url = '/slots/' + str(params['slot_name']) + '/poe'
+    method = 'PUT'
+
+    diffSeen = False
+    check_presence = get_config(module, url)
+    newdata = json.loads(check_presence)
+    for key in data:
+        if not newdata[key] == data[key]:
+            diffSeen = True
+            break
+
+    if diffSeen:
+        result = run_commands(module, url, data, method, check=url)
+        return result
+    else:
+        return {'msg': 'Already Configured',
+                'changed': False, 'failed': False}
+
+
+"""
+-------
+Name: run_module()
+
+The main module invoked
+
+Returns
+ Configure the switch with params sent
+-------
+"""
+def run_module():
+    module_args = dict(
+        command=dict(type='str', required=False, default="config_poe",
+            choices=["reset_poe_port", "config_poe_port", "config_poe_slot"]),
+        port_id=dict(type='str', required=False, default=""),
+        is_poe_enabled=dict(type='bool', required=False, default=True),
+        poe_priority=dict(type='str', required=False, default="PPP_LOW",
+            choices=["PPP_CRITICAL", "PPP_HIGH", "PPP_LOW"]),
+        poe_allocation_method=dict(type='str', required=False, default="PPAM_USAGE",
+            choices=["PPAM_USAGE", "PPAM_CLASS", "PPAM_VALUE"]),
+        allocated_power_in_watts=dict(type='int', required=False, default=1),
+        port_configured_type=dict(type='str', required=False, default=""),
+        pre_standard_detect_enabled=dict(type='bool', required=False, default=False),
+        slot_name=dict(type='str', required=False, default=""),
+        power_threshold_percentage=dict(type='int', required=False, default=1),
+    )
+
+    module_args.update(arubaoss_argument_spec)
+
+    result = dict(changed=False,warnings='Not Supported')
+
+    module = AnsibleModule(
+        argument_spec=module_args,
+        supports_check_mode=True
+    )
+
+    if module.check_mode:
+        module.exit_json(**result)
+
+    try:
+        if module.params['command'] == "reset_poe_port":
+            result = reset_poe_port(module)
+        if module.params['command'] == "config_poe_slot":
+            result = config_poe_slot(module)
+        else:
+            result = config_poe_port(module)
+    except Exception as err:
+        return module.fail_json(msg=err)
+
+    module.exit_json(**result)
+
+def main():
+    run_module()
+
+if __name__ == '__main__':
+    main()
diff --git a/ansible/modules/network/arubaoss/arubaoss_port_rate_limit.py b/ansible/modules/network/arubaoss/arubaoss_port_rate_limit.py
new file mode 100644
index 0000000..51e1d8d
--- /dev/null
+++ b/ansible/modules/network/arubaoss/arubaoss_port_rate_limit.py
@@ -0,0 +1,326 @@
+#!/usr/bin/python
+
+ANSIBLE_METADATA = {
+    'metadata_version': '1.1',
+    'status': ['preview'],
+    'supported_by': 'community'
+}
+
+DOCUMENTATION = '''
+---
+module: arubaoss_port_rate_limit
+
+short_description: implements rest api for AAA Accounting configuration
+
+version_added: "2.4"
+
+description:
+    - "This implements rest apis which can be used to configure AAA Accounting"
+
+options:
+    command:
+        description: Function name calls according to configuration required
+        choices: update_rate_limit_attributes, clear_rate_limit_trap,
+                  update_rate_limit_onPort, update_rate_limit_attributes_onPort
+        required: False
+    port_id
+        description: Port_id of the port
+        required: True
+    icmp_traffic_type
+        description: ICMP traffic type. Default is "PITT_IP_V4"
+        choices: PITT_IP_ALL, PITT_IP_V4, PITT_IP_V6
+        required: False
+    icmp_rate_limit
+        description: ICMP Rate Limit value.
+        required: False
+    queues_direction
+        description: Queue traffic direction. port_id and queues_direction
+                     are required to uniquely identify the
+                     queue_rate_percentage to be set
+        choices: PTD_OUT
+        required: False
+    queue_rate_percentage
+        description: Rate limit for each egress queue in percentage. Apply
+                     the default value on all queues to reset the configuration
+        required: False
+    traffic_type
+        description: The traffic type. port_id, traffic_type and direction are
+                     required to uniquely identify the rate_limit value to be set
+        choices: PTT_BCAST, PTT_MCAST, PTT_ALL, PTT_UKWN_UNCST
+        required: False
+    direction:
+        description: Traffic flow direction. port_id, traffic_type and direction
+                     are required to uniquely identify the rate_limit value to be set.
+                     PTD_OUT is applicable, only when traffic_type is PTT_ALL on
+                     specific platforms
+        choices: PTD_IN, PTD_OUT
+        required: False
+    rate_limit
+        description: Rate limit value. rate_limit_in_kbps and rate_limit_in_percent
+                     will be null if rate_limit is not configured
+        required: False
+
+
+author:
+    - Sanju Sadanandan (@hpe)
+'''
+
+EXAMPLES = '''
+     - name: Updates attributes of port ICMP rate limit per port id
+       arubaoss_port_rate_limit:
+         command: update_rate_limit_attributes
+         port_id: 1
+         icmp_traffic_type: "PITT_IP_ALL"
+         rate_limit_in_kbps: "10"
+         rate_limit_in_percent: "0"
+
+'''
+
+RETURN = '''
+original_message:
+    description: The original name param that was passed in
+    type: str
+message:
+    description: The output message that the sample module generates
+'''
+
+from ansible.module_utils.basic import AnsibleModule
+from ansible.module_utils.network.arubaoss.arubaoss import run_commands
+from ansible.module_utils.network.arubaoss.arubaoss import arubaoss_argument_spec
+from ansible.module_utils.network.arubaoss.arubaoss import get_config
+import sys, json
+
+"""
+-------
+Name: update_rate_limit_attributes
+
+Updates attributes of port ICMP rate limit per port id
+
+param request: module
+
+Returns
+ Configure the switch with params sent
+-------
+"""
+def update_rate_limit_attributes(module):
+
+    params = module.params
+
+    data = {}
+    data['icmp_rate_limit'] = {'rate_limit_in_percent': 10}
+
+    data['port_id'] = params ['port_id']
+    data['icmp_traffic_type'] = params['icmp_traffic_type']
+
+    # Rate limit should be in kbps or percent
+    if params['rate_limit_in_kbps'] == 0:
+        data['icmp_rate_limit'] = {'rate_limit_in_percent': params['rate_limit_in_percent']}
+    else:
+        data['icmp_rate_limit'] = {'rate_limit_in_kbps': params['rate_limit_in_kbps']}
+
+    url = '/ports/icmp_rate_limit/' + str(params['port_id'])
+    method = 'PUT'
+
+    result = run_commands(module, url, data, method)
+    return result
+
+    # Idempotency check: Check if already configured
+    diffSeen = False
+    check_presence = get_config(module, url)
+    newdata = json.loads(check_presence)
+    for key in data:
+        if not newdata[key] == data[key]:
+            diffSeen = True
+            if params['rate_limit_in_percent'] == 0 and newdata[key]['rate_limit_in_percent'] == None:
+                diffSeen = False
+            if params['rate_limit_in_kbps'] == 0 and newdata[key]['rate_limit_in_kbps'] == None:
+                diffSeen = False
+            break
+
+    if diffSeen:
+        result = run_commands(module, url, data, method)
+        return result
+    else:
+        return {'msg': 'Already configured',
+                   'changed': False, 'failed': False}
+
+"""
+-------
+Name: clear_rate_limit_trap
+
+Trap-clear for ICMP rate-limit on a port.
+
+param request: module
+
+Returns
+ Configure the switch with params sent
+-------
+"""
+def clear_rate_limit_trap(module):
+
+    params = module.params
+
+    data = {}
+    data['port_id'] = params['port_id']
+    data['icmp_traffic_type'] = params['icmp_traffic_type']
+
+    url = '/ports/icmp_rate_limit_trap_clear/' + str(params['port_id'])
+    method = 'POST'
+
+    result = run_commands(module, url, data, method)
+    return result
+
+"""
+-------
+Name: update_rate_limit_onPort
+
+Updates attributes of port ICMP rate limit per port id
+
+param request: module
+
+Returns
+ Configure the switch with params sent
+-------
+"""
+def update_rate_limit_onPort(module):
+
+    params = module.params
+
+    data = {}
+
+    data['queues_direction'] = params['queues_direction']
+    data['port_id'] = params['port_id']
+
+    data['queue_rate_percentage'] = [
+                 params['queue_rate_percentage_1'], params['queue_rate_percentage_2'],
+                 params['queue_rate_percentage_3'], params['queue_rate_percentage_4'],
+                 params['queue_rate_percentage_5'], params['queue_rate_percentage_6'],
+                 params['queue_rate_percentage_7'], params['queue_rate_percentage_8']]
+
+    url = '/ports/queues_rate_limit/' + str(params['port_id']) + "-" + str(params['queues_direction'])
+    method = 'PUT'
+
+    result = run_commands(module, url, data, method, check=url)
+
+    return result
+"""
+-------
+Name: update_rate_limit_attributes_onPort
+
+Updates attributes of port rate limit per port id, traffic type and direction
+
+param request: module
+
+Returns
+ Configure the switch with params sent
+-------
+"""
+def update_rate_limit_attributes_onPort(module):
+
+    params = module.params
+
+    data = {}
+    data['port_id'] = params['port_id']
+    data['traffic_type'] = params['traffic_type']
+    data['direction'] = params['direction']
+    data['rate_limit'] = params['rate_limit']
+
+    # Rate limit should be in kbps or percent
+    if params['rate_limit_in_kbps'] == 0:
+        data['rate_limit'] = {'rate_limit_in_percent': params['rate_limit_in_percent']}
+    else:
+        data['rate_limit'] = {'rate_limit_in_kbps': params['rate_limit_in_kbps']}
+
+    url = '/ports/rate_limit/' + str(params['port_id']) + "-" + str(params['traffic_type']) + "-" + str(params['direction'])
+    method = 'PUT'
+
+    # Idempotency check: Check if already configured
+    diffSeen = False
+    check_presence = get_config(module, url)
+    newdata = json.loads(check_presence)
+    for key in data:
+        if not newdata[key] == data[key]:
+            diffSeen = True
+            if params['rate_limit_in_percent'] == 0 and newdata[key]['rate_limit_in_percent'] == None:
+                diffSeen = False
+            if params['rate_limit_in_kbps'] == 0 and newdata[key]['rate_limit_in_kbps'] == None:
+                diffSeen = False
+            break
+
+    if diffSeen:
+        result = run_commands(module, url, data, method)
+        return result
+    else:
+        return {'msg': 'Already configured',
+                   'changed': False, 'failed': False}
+
+"""
+-------
+Name: run_module()
+
+The main module invoked
+
+Returns
+ Configure the switch with params sent
+-------
+"""
+def run_module():
+    module_args = dict(
+        command=dict(type='str', required=False, default='update_rate_limit_attributes',
+               choices = ["update_rate_limit_attributes", "clear_rate_limit_trap",
+                          "update_rate_limit_onPort", "update_rate_limit_attributes_onPort"]),
+        config=dict(type='str', required=False, default='create',
+               choices = ["create", "Delete"]),
+        port_id=dict(type='str', required=False),
+        icmp_traffic_type=dict(type='str', required=False, default="PITT_IP_V4",
+               choices = ["PITT_IP_ALL","PITT_IP_V4","PITT_IP_V6"]),
+        rate_limit_in_kbps=dict(type='int', required=False, default=0),
+        rate_limit_in_percent=dict(type='int', required=False, default=0),
+        queues_direction=dict(type='str', required=False, default="PQTD_OUT",
+               choices = ["PQTD_OUT"]),
+        queue_rate_percentage_1=dict(type='int', required=False, default=100),
+        queue_rate_percentage_2=dict(type='int', required=False, default=100),
+        queue_rate_percentage_3=dict(type='int', required=False, default=100),
+        queue_rate_percentage_4=dict(type='int', required=False, default=100),
+        queue_rate_percentage_5=dict(type='int', required=False, default=100),
+        queue_rate_percentage_6=dict(type='int', required=False, default=100),
+        queue_rate_percentage_7=dict(type='int', required=False, default=100),
+        queue_rate_percentage_8=dict(type='int', required=False, default=100),
+        traffic_type=dict(type='str', required=False, default="PTT_ALL",
+               choices = ["PTT_BCAST", "PTT_MCAST", "PTT_ALL", "PTT_UKWN_UNCST"]),
+        direction=dict(type='str', required=False, default="PTD_IN",
+               choices = ["PTD_IN", "PTD_OUT"]),
+        rate_limit=dict(type='str', required=False, default=""),
+    )
+
+    module_args.update(arubaoss_argument_spec)
+
+    result = dict(changed=False)
+
+    module = AnsibleModule(
+        argument_spec=module_args,
+        supports_check_mode=True
+    )
+
+    if module.check_mode:
+        return result
+
+    try:
+        if module.params['command'] == "update_rate_limit_attributes":
+            result = update_rate_limit_attributes(module)
+        elif module.params['command'] == "clear_rate_limit_trap":
+            result = clear_rate_limit_trap(module)
+        elif module.params['command'] == "update_rate_limit_onPort":
+            result = update_rate_limit_onPort(module)
+        else:
+            result = update_rate_limit_attributes_onPort(module)
+    except Exception as err:
+        return module.fail_json(msg=err)
+
+    module.exit_json(**result)
+
+def main():
+    run_module()
+
+if __name__ == '__main__':
+    main()
diff --git a/ansible/modules/network/arubaoss/arubaoss_qos_policy.py b/ansible/modules/network/arubaoss/arubaoss_qos_policy.py
new file mode 100644
index 0000000..ef27abc
--- /dev/null
+++ b/ansible/modules/network/arubaoss/arubaoss_qos_policy.py
@@ -0,0 +1,251 @@
+#!/usr/bin/python
+
+ANSIBLE_METADATA = {
+    'metadata_version': '1.1',
+    'status': ['preview'],
+    'supported_by': 'community'
+}
+
+DOCUMENTATION = '''
+---
+module: arubaoss_qos_policy
+
+short_description: implements rest api for qos configuration
+
+version_added: "2.6"
+
+description:
+    - "This implements rest api's which can be used to configure qos
+       on device."
+
+options:
+    class_name:
+        description:
+            - traffic class name
+        required: false
+    class_type:
+        description:
+            - traffic class type
+        required: false
+        choices: QCT_IP_V4, QCT_IP_V6
+        default: QCT_IP_V4
+    policy_name:
+        description:
+            - qos policy name
+        required: true
+    policy_type:
+        description:
+            - Type of qos. Onlye QOS_QPT is supported
+        required: false
+    action:
+        description:
+            - Type of qos action to take.
+        requried: false
+        default: QPAT_RATE_LIMIT
+        choices: QPAT_RATE_LIMIT, QPAT_PRIORITY, QPAT_DSCP_VALUE
+    action_value:
+        description:
+            - Value for each action.
+        required: false
+    sequence_no:
+        description:
+            - Sequence number for traffic class
+        required: false
+
+
+author:
+    - Ashish Pant (@hpe)
+'''
+
+EXAMPLES = '''
+      - name: create qos policy
+        arubaoss_qos_policy:
+          policy_name: my_qos
+
+      - name: attach class to qos
+        arubaoss_qos_policy:
+          policy_name: my_qos
+          class_name: my_class
+          action: QPAT_RATE_LIMIT
+          action_value: 1000
+          sequence_no: "{{class_1.sequence_no}}"
+
+      - name: delete qos policy
+        arubaoss_qos_policy:
+          policy_name: my_qos
+          state: delete
+
+'''
+
+
+from ansible.module_utils.basic import AnsibleModule
+from ansible.module_utils.network.arubaoss.arubaoss import run_commands,get_config
+from ansible.module_utils.network.arubaoss.arubaoss import arubaoss_argument_spec
+from ansible.module_utils._text import to_text
+
+
+def qos(module):
+
+    params = module.params
+
+    url = '/qos/policies'
+    policy_id = params['policy_name'] + '~' + params['policy_type']
+
+    check_url = url + '/' + policy_id
+
+    if params['state'] == 'create':
+
+        data = {
+                'policy_name': params['policy_name'],
+                'policy_type': params['policy_type'],
+                }
+        method = 'POST'
+
+    else:
+        # Check if qos is applied to any port
+        qos_url = '/qos/ports-policies'
+        qos_config = get_config(module,qos_url)
+        if qos_config:
+            qos_config = module.from_json(to_text(qos_config))
+            for config in qos_config['qos_port_policy_element']:
+                if policy_id == config['policy_id']:
+                    return {'msg': 'Cannot delete policy {}, active on port {}'.\
+                            format(policy_id,config['port_id']),'change':False}
+
+        # Check if qos is applied to any port
+        qos_url = '/qos/vlans-policies'
+        qos_config = get_config(module,qos_url)
+        if qos_config:
+            qos_config = module.from_json(to_text(qos_config))
+            for config in qos_config['qos_vlan_policy_element']:
+                if policy_id == config['policy_id']:
+                    return {'msg': 'Cannot delete policy {}, active on vlan {}'.\
+                            format(policy_id,config['vlan_id']),'change':False}
+
+
+        data = {}
+        method = 'DELETE'
+        url = check_url
+
+    result = run_commands(module, url, data, method, check=check_url)
+
+    return result
+
+
+def qos_class(module):
+
+    params = module.params
+    policy_id = params['policy_name'] + '~' + params['policy_type']
+    url = '/qos/policies/' + policy_id + '/policy-actions'
+
+    # Create qos if not to apply actions
+    if params['state'] == 'create':
+        qos(module)
+
+    method = 'POST'
+    if params['sequence_no'] > 0:
+        temp = url + '/' + str(params['sequence_no'])
+        if get_config(module, temp):
+            url = url + '/' + str(params['sequence_no'])
+            method = 'PUT'
+
+
+    if params['state'] == 'create':
+        class_id = params['class_name'] + '~' + params['class_type']
+
+        class_url = '/qos/traffic-classes/' + class_id
+
+        if not get_config(module, class_url):
+            return {'msg': 'class does not exist', 'changed':False}
+
+        if params['action_value'] == -1 or not params['action']:
+            return {'msg':'action and action_type are required','changed':False}
+
+        action = params['action']
+        action_value = params['action_value']
+
+        data = {
+                'policy_id': policy_id,
+                'traffic_class_id': class_id,
+                'first_action': {
+                    'action_type': action,
+                    },
+                'sequence_no': params['sequence_no'],
+                }
+
+        if action == 'QPAT_RATE_LIMIT':
+            data['first_action']['rate_limit_in_kbps'] = action_value
+        elif action == 'QPAT_DSCP_VALUE':
+            data['first_action']['new_dscp_value'] = action_value
+        else:
+            data['first_action']['new_priority'] = action_value
+
+        qos_config = get_config(module, url)
+        if qos_config:
+            check_config = module.from_json(to_text(qos_config))
+            if params['sequence_no'] == 0:
+                for config in check_config['qos_policy_action_element']:
+                    if class_id == config['traffic_class_id']:
+                        return config
+            elif params['sequence_no'] > 0:
+                if check_config.get('traffic_class_id') and class_id == check_config['traffic_class_id']:
+                    return check_config
+
+        result = run_commands(module, url, data, method)
+    else:
+        if params['sequence_no'] ==0:
+            return {'msg':'sequence_no is required','changed':False}
+        else:
+            url = url + '/' + str(params['sequence_no'])
+
+        result = run_commands(module, url, {}, 'DELETE',check=url)
+
+    return result
+
+
+def run_module():
+    module_args = dict(
+        class_name=dict(type='str', required=False),
+        class_type=dict(type='str', required=False,default='QCT_IP_V4',
+            choices=['QCT_IP_V4','QCT_IP_V6']),
+        policy_name=dict(type='str', required=True),
+        policy_type=dict(type='str', required=False,default='QPT_QOS'),
+        state=dict(type='str', required=False, default='create',
+            choices=['create','delete']),
+        action=dict(type='str', required=False, default='QPAT_RATE_LIMIT',
+            choices=['QPAT_PRIORITY','QPAT_DSCP_VALUE','QPAT_RATE_LIMIT']),
+        action_value=dict(type='int', reqquired=False, default=-1),
+        sequence_no=dict(type='int', required=False, default=0),
+    )
+
+    module_args.update(arubaoss_argument_spec)
+
+
+    result = dict(changed=False,warnings='Not Supported')
+
+    module = AnsibleModule(
+        argument_spec=module_args,
+        supports_check_mode=True
+    )
+
+    if module.check_mode:
+        module.exit_json(**result)
+
+    try:
+
+        if module.params['class_name']:
+            result = qos_class(module)
+        else:
+            result = qos(module)
+
+    except Exception as err:
+        return module.fail_json(msg=err)
+
+    module.exit_json(**result)
+
+
+def main():
+    run_module()
+
+if __name__ == '__main__':
+    main()
diff --git a/ansible/modules/network/arubaoss/arubaoss_radius_profile.py b/ansible/modules/network/arubaoss/arubaoss_radius_profile.py
new file mode 100644
index 0000000..c3de9ca
--- /dev/null
+++ b/ansible/modules/network/arubaoss/arubaoss_radius_profile.py
@@ -0,0 +1,302 @@
+#!/usr/bin/python
+
+ANSIBLE_METADATA = {
+    'metadata_version': '1.1',
+    'status': ['preview'],
+    'supported_by': 'community'
+}
+
+DOCUMENTATION = '''
+---
+module: arubaoss_radius_profile
+
+short_description: implements rest api for aaa configuration
+
+version_added: "2.4"
+
+description:
+    - "This implements rest apis which can be used to configure RADIUS Server"
+
+options:
+    command:
+        description: Function name calls according to configuration required
+        choices: config_radius_profile,config_radius_serverGroup,config_radius_server
+        required: True
+    config:
+        description: To config or unconfig the required command
+        choices: create, delete
+        required: False
+    retry_interval
+        description: The RADIUS server retry interval
+        required: False
+    retransmit_attempts
+        description: The RADIUS server retransmit attempts
+        required: False
+    dead_time
+        description: The RADIUS server dead_time. dead_time cannot set when
+                     is_tracking_enabled is true. Input dead_time as null to
+                     reset the value. dead_time is indicated as null instead of '0' in CLI
+        required: False
+    dyn_autz_port
+        description: The RADIUS dyn_autz_port
+        required: False
+    key
+        description: The RADIUS server key. Input key as empty string to reset the value
+        required: False
+    tracking_uname
+        description: The RADIUS tracking_uname, default is radius-tracking-user
+        required: False
+    is_tracking_enabled
+        description: The RADIUS server for if tracking is enabled . The flag is_tracking_enabled,
+                     cannot set to true when dead_time is configured
+        required: False
+    cppm_details
+        description: Username and password combination of CPPM which is used to
+                     login to CPPM to download user roles
+        required: False
+    server_ip
+        description: IP Address of the Radius Server
+        required: False
+    shared_secret
+        description: The Radius server shared secret
+        required: False
+    version
+        description: Version of the IP Address used
+        choices: IAV_IP_V4. (V6 is not supported via REST)
+        required: False
+    server_group_name
+        description: Server Group name
+        required: False
+   time_window_type
+        description: Time window type
+        choices: TW_POSITIVE_TIME_WINDOW, TW_PLUS_OR_MINUS_TIME_WINDOW
+        required: False
+    server_ip
+        description: Radius server hosts. Minimum is 1 servers, and maximum is 3
+        required: False
+author:
+    - Sanju Sadanandan (@hpe)
+'''
+
+EXAMPLES = '''
+     - name: Updates the radius profile details on system
+       arubaoss_radius_profile:
+         command: config_radius_profile
+         retry_interval: 7
+         retransmit_attempts: 5
+         dead_time: 12
+         dyn_autz_port: 3799
+         key: ""
+         tracking_uname: "radius-tracking-user"
+         is_tracking_enabled: false
+         cppm_details: null
+'''
+
+from ansible.module_utils.basic import AnsibleModule
+from ansible.module_utils.network.arubaoss.arubaoss import run_commands
+from ansible.module_utils.network.arubaoss.arubaoss import arubaoss_argument_spec
+from ansible.module_utils.network.arubaoss.arubaoss import get_config
+
+"""
+-------
+Name: config_radius_profile
+
+Configures port with radius profile config
+
+param request: module
+
+Returns
+ Configure the switch with params sent
+-------
+"""
+def config_radius_profile(module):
+
+    params = module.params
+
+    data = {}
+    data['retry_interval'] = params['retry_interval']
+    data['retransmit_attempts'] = params['retransmit_attempts']
+    data['dyn_autz_port'] = params['dyn_autz_port']
+    data['key'] = params['key']
+    data['tracking_uname'] = params['tracking_uname']
+    data['is_tracking_enabled'] = params['is_tracking_enabled']
+
+    if params['is_tracking_enabled'] == True:
+        return {'msg': "dead_time cannot set when is_tracking_enabled is true",
+                'changed': False, 'failed': False}
+    else:
+        data['dead_time'] = params['dead_time']
+
+    data['cppm_details'] = params['cppm_details']
+
+    url = '/radius_profile'
+    method = 'PUT'
+
+    result = run_commands(module, url, data, method, check=url)
+    return result
+"""
+-------
+Name: config_radius_serverGroup
+
+Configures port with radius server Group details
+
+param request: module
+
+Returns
+ Configure the switch with params sent
+-------
+"""
+def config_radius_serverGroup(module):
+
+    params = module.params
+
+    data = {}
+    if params['server_ip'] == "" or params['version'] == "":
+        return {'msg': "IP Address or version cannot be null",
+                'changed': False, 'failed': False}
+    else:
+        data["server_ip"] = [{'version': params['version'], 'octets': params['server_ip']}]
+
+    if params['server_group_name'] == "":
+        return {'msg': "Server group name cannot be null",
+                'changed': False, 'failed': False}
+    else:
+        data["server_group_name"] = params['server_group_name']
+
+    method = 'POST'
+    url = '/radius/server_group'
+    del_url = '/radius/server_group/' + str(params['server_group_name'])
+
+    if params['config'] == "create":
+       method = 'POST'
+    else:
+       url = del_url
+       method = 'DELETE'
+
+    result = run_commands(module, url, data, method, check=del_url)
+    return result
+
+"""
+-------
+Name: config_radius_server
+
+Configures port with radius server details
+
+param request: module
+
+Returns
+ Configure the switch with params sent
+-------
+"""
+def config_radius_server(module):
+
+    params = module.params
+
+    data = {}
+    data["radius_server_id"] = params['radius_server_id']
+
+    if params['server_ip'] == "" or params['version'] == "":
+        return {'msg': "IP Address or version cannot be null",
+                'changed': False, 'failed': False}
+    else:
+        data["address"] = {'version': params['version'], 'octets': params['server_ip']}
+
+    if params['shared_secret'] == "":
+        return {'msg': "Shared secret cannot be null",
+                'changed': False, 'failed': False}
+    else:
+        data["shared_secret"] = params['shared_secret']
+
+    data["authentication_port"] = params['authentication_port']
+    data["accounting_port"] = params['accounting_port']
+    data["is_dyn_authorization_enabled"] = params['is_dyn_authorization_enabled']
+    data["time_window_type"] = params['time_window_type']
+    data["time_window"] = params['time_window']
+    data["is_oobm"] = params['is_oobm']
+
+    create_url = '/radius_servers'
+    check_url = '/radius_servers/' + str(params['radius_server_id'])
+
+    if params['config'] == "create":
+       # Check if it already exists
+       check_presence = get_config(module, check_url)
+       if not check_presence:
+           url = create_url
+           method = 'POST'
+       else:
+           url = check_url
+           method = 'PUT'
+    else:
+       url = check_url
+       method = 'DELETE'
+
+    result = run_commands(module, url, data, method,check=check_url)
+    return result
+"""
+-------
+Name: run_module()
+
+The main module invoked
+
+Returns
+ Configure the switch with params sent
+-------
+"""
+def run_module():
+    module_args = dict(
+        command=dict(type='str', required=True,
+           choices=['config_radius_profile','config_radius_serverGroup','config_radius_server']),
+        config=dict(type='str', required=False, default="create",
+           choices=['create','delete']),
+        retry_interval=dict(type='int', required=False, default='7'),
+        retransmit_attempts=dict(type='int', required=False, default='5'),
+        dead_time=dict(type='int', required=False, default='10'),
+        dyn_autz_port=dict(type='int', required=False, default=3799),
+        key=dict(type='str', required=False, default=""),
+        tracking_uname=dict(type='str', required=False, default='radius-tracking-user'),
+        is_tracking_enabled=dict(type='bool', required=False, default=False),
+        cppm_details=dict(type='str', required=False, default='0'),
+        server_ip=dict(type='str', required=False, default=""),
+        shared_secret=dict(type='str', required=False, default=""),
+        version=dict(type='str', required=False, default="IAV_IP_V4",
+            choices=["IAV_IP_V4"]),
+        server_group_name=dict(type='str', required=False, default=""),
+        radius_server_id=dict(type='int', required=False, default=1),
+        authentication_port=dict(type='int', required=False, default="1812"),
+        accounting_port=dict(type='int', required=False, default="1813"),
+        is_dyn_authorization_enabled=dict(type='bool', required=False, default=False),
+        time_window_type=dict(type='str', required=False, default="TW_POSITIVE_TIME_WINDOW",
+            choices=['TW_POSITIVE_TIME_WINDOW', 'TW_PLUS_OR_MINUS_TIME_WINDOW']),
+        time_window=dict(type='int', required=False, default="300"),
+        is_oobm=dict(type='bool', required=False,default=False),
+    )
+
+    module_args.update(arubaoss_argument_spec)
+
+    result = dict(changed=False,warnings='Not Supported')
+
+    module = AnsibleModule(
+        argument_spec=module_args,
+        supports_check_mode=True
+    )
+
+    if module.check_mode:
+        module.exit_json(**result)
+
+    try:
+        if module.params['command'] == "config_radius_profile":
+            result = config_radius_profile(module)
+        elif module.params['command'] == "config_radius_serverGroup":
+            result = config_radius_serverGroup(module)
+        else:
+            result = config_radius_server(module)
+    except Exception as err:
+        return module.fail_json(msg=err)
+
+    module.exit_json(**result)
+
+def main():
+    run_module()
+
+if __name__ == '__main__':
+    main()
diff --git a/ansible/modules/network/arubaoss/arubaoss_reboot.py b/ansible/modules/network/arubaoss/arubaoss_reboot.py
new file mode 100644
index 0000000..33c18dc
--- /dev/null
+++ b/ansible/modules/network/arubaoss/arubaoss_reboot.py
@@ -0,0 +1,137 @@
+#!/usr/bin/python
+
+ANSIBLE_METADATA = {
+    'metadata_version': '1.1',
+    'status': ['preview'],
+    'supported_by': 'community'
+}
+
+DOCUMENTATION = '''
+---
+module: arubaoss_reboot
+
+short_description: reboots the device
+
+version_added: "2.6"
+
+description:
+    - "This reboots the device and waits until it comes up.
+       User has an option to disable the wait and just send
+       the reboot to device"
+
+options:
+    boot_image:
+        description:
+            - Boots device using this image
+        default: BI_PRIMARY_IMAGE
+        choices: BI_PRIMARY_IMAGE, BI_SECONDARY_IMAGE
+        required: true
+    is_wait:
+        description:
+            - Wait for boot or skip the reboot
+        default: true
+        choice: true, false
+        required: false
+
+author:
+    - Ashish Pant (@hpe)
+'''
+
+EXAMPLES = '''
+      - name: reboot device
+        arubaoss_reboot:
+          boot_image: BI_SECONDARY_IMAGE
+          is_wait: False
+
+'''
+
+from ansible.module_utils.basic import AnsibleModule
+from ansible.module_utils.network.arubaoss.arubaoss import run_commands,get_config
+from ansible.module_utils.network.arubaoss.arubaoss import arubaoss_argument_spec
+from time import sleep, time
+
+
+def wait_for_boot(module):
+
+    url = '/system/status'
+    wait = 1
+
+    msg_queue = []
+    while wait <= 60:
+        result = get_config(module, url, check_login=False)
+        if result:
+            return result
+
+        sleep(5)
+        wait += 1
+
+    return False
+
+
+def reboot(module):
+
+    params = module.params
+    url = '/system/reboot'
+
+    status_url = '/system/status'
+    result = get_config(module, status_url)
+    if not result:
+        return {'msg':'Could not get devcie status. Not rebooted!','changed':False,
+                'failed':True}
+
+    data = {
+            'boot_image': params['boot_image'],
+            }
+
+    result = run_commands(module, url, data, 'reboot')
+    total_time = 0
+
+    if result['message'] == 'Device is rebooting' and params['is_wait']:
+        start = time()
+        result  = wait_for_boot(module)
+
+        end = time()
+        total_time = int(end-start)
+
+        if result:
+            result = {'changed':True,'msg': 'Device reboot successful.','total_time':total_time}
+        else:
+            result = {'failed': True,'msg': 'Device reboot failed.','total_time': total_time}
+
+
+
+    return result
+
+
+def run_module():
+    module_args = dict(
+        boot_image=dict(type='str', required=False, default='BI_PRIMARY_IMAGE',
+            choices=['BI_PRIMARY_IMAGE','BI_SECONDARY_IMAGE']),
+        is_wait=dict(type='bool', required=False, default=True)
+    )
+
+    module_args.update(arubaoss_argument_spec)
+
+    result = dict(changed=False,warnings='Not Supported')
+
+    module = AnsibleModule(
+        argument_spec=module_args,
+        supports_check_mode=True
+    )
+
+    if module.check_mode:
+        module.exit_json(**result)
+
+    try:
+        result = reboot(module)
+    except Exception as err:
+        return module.fail_json(msg=err)
+
+    module.exit_json(**result)
+
+
+def main():
+    run_module()
+
+if __name__ == '__main__':
+    main()
diff --git a/ansible/modules/network/arubaoss/arubaoss_routing.py b/ansible/modules/network/arubaoss/arubaoss_routing.py
new file mode 100644
index 0000000..9dc0e67
--- /dev/null
+++ b/ansible/modules/network/arubaoss/arubaoss_routing.py
@@ -0,0 +1,99 @@
+#!/usr/bin/python
+
+ANSIBLE_METADATA = {
+    'metadata_version': '1.1',
+    'status': ['preview'],
+    'supported_by': 'community'
+}
+
+DOCUMENTATION = '''
+---
+module: arubaoss_routing
+
+short_description: implements rest api for routing
+
+version_added: "2.6"
+
+description:
+    - "This implements routing rest api to enable/disable routing on device"
+
+options:
+    state:
+        description:
+            - To enable/disable routing globally.
+        required: true
+        choices: create, delete
+
+
+author:
+    - Ashish Pant (@hpe)
+'''
+
+EXAMPLES = '''
+     - name: enable routing
+       arubaoss_routing:
+         state: create
+
+     - name: disable routing
+       arubaoss_routing:
+         state: delete
+
+'''
+
+from ansible.module_utils.basic import AnsibleModule
+from ansible.module_utils.network.arubaoss.arubaoss import run_commands
+from ansible.module_utils.network.arubaoss.arubaoss import arubaoss_argument_spec
+
+
+def routing(module):
+
+    params = module.params
+    url = "/ip-route/settings"
+
+    if params['state'] == 'create':
+        true = True
+    else:
+        true = False
+    data = {'is_ip_routing_enable':true}
+
+    result = run_commands(module, url, data, 'PUT',check=url)
+
+    return result
+
+def run_module():
+    # define the available arguments/parameters that a user can pass to
+    # the module
+    module_args = dict(
+        state=dict(type='str', required=False, choices=['create','delete']),
+    )
+
+    module_args.update(arubaoss_argument_spec)
+
+    result = dict(changed=False)
+
+
+    module = AnsibleModule(
+        argument_spec=module_args,
+        supports_check_mode=True
+    )
+
+    # if the user is working with this module in only check mode we do not
+    # want to make any changes to the environment, just return the current
+    # state with no modifications
+    if module.check_mode:
+        return result
+
+    try:
+        result = routing(module)
+    except Exception as err:
+        return module.fail_json(msg=err)
+
+    # in the event of a successful module execution, you will want to
+    # simple AnsibleModule.exit_json(), passing the key/value results
+    module.exit_json(**result)
+
+def main():
+    run_module()
+
+if __name__ == '__main__':
+    main()
diff --git a/ansible/modules/network/arubaoss/arubaoss_snmp.py b/ansible/modules/network/arubaoss/arubaoss_snmp.py
new file mode 100644
index 0000000..8d04c31
--- /dev/null
+++ b/ansible/modules/network/arubaoss/arubaoss_snmp.py
@@ -0,0 +1,365 @@
+#!/usr/bin/python
+
+ANSIBLE_METADATA = {
+    'metadata_version': '1.1',
+    'status': ['preview'],
+    'supported_by': 'community'
+}
+
+DOCUMENTATION = '''
+---
+module: arubaoss_snmp
+
+short_description: implements rest api for snmp configuration
+
+version_added: "2.6"
+
+description:
+    - "This implements rest api's which configure snmp on device"
+
+options:
+    commmunity_nme:
+        description:
+            - snmp community name. Required when configuring community
+        required: false
+    access_type:
+        description:
+            - Type of access required. Operator or Manager.
+        required: false
+    restricted:
+        description:
+            - Extent of access restricted or unrestricted
+        required: false
+    host_ip:
+        description:
+            - Snmp host ip address
+        required: false
+    version:
+        description:
+            - Host IP address version
+        required: false
+    informs:
+        description:
+            - Enable/disables informs to host
+        required: false
+    inform_timeout:
+        description:
+            - Timeout for informs
+        required: false
+    inform_retires:
+        description:
+            - Retries required for informs
+        required: false
+    trap_level:
+        description:
+            - Trap level for host
+        required: false
+    use_oobm:
+        description:
+            - Enable/disable oobm port usage
+        required: false
+    location:
+        description:
+            - Server location
+        required: false
+    contact:
+        description:
+            - Server contact
+        required: false
+
+
+author:
+    - Ashish Pant (@hpe)
+'''
+
+EXAMPLES = '''
+      - name: configure snmp community
+        arubaoss_snmp:
+          community_name: test
+          access_type: "{{item}}"
+        with_items:
+          - UT_MANAGER
+          - UT_MANAGER
+          - UT_OPERATOR
+          - UT_OPERATOR
+
+      - name: configure snmp community
+        arubaoss_snmp:
+          community_name: test
+          access_type: "{{item.role}}"
+          restricted: "{{item.res}}"
+        with_items:
+          - {"role":"UT_MANAGER","res":False}
+          - {"role":"UT_MANAGER","res":True}
+          - {"role":"UT_MANAGER","res":True}
+          - {"role":"UT_OPERATOR","res":False}
+          - {"role":"UT_OPERATOR","res":True}
+          - {"role":"UT_OPERATOR","res":True}
+
+
+      - name: configure snmp host
+        arubaoss_snmp:
+          community_name: test
+          host_ip: "{{item}}"
+        with_items:
+          - 10.1.1.1
+          - 10.1.1.1
+
+      - name: configure snmp host inform
+        arubaoss_snmp:
+          community_name: test
+          host_ip: 10.1.1.1
+          informs: "{{item}}"
+        with_items:
+          - True
+          - True
+          - False
+
+      - name: configure snmp host inform retry timeout
+        arubaoss_snmp:
+          community_name: test
+          host_ip: 10.1.1.1
+          informs: True
+          inform_retries: "{{item.retry}}"
+          inform_timeout: "{{item.timeout}}"
+        with_items:
+          - {"retry":10,"timeout":20}
+          - {"retry":100,"timeout":200}
+
+      - name: delete snmp host inform retry timeout
+        arubaoss_snmp:
+          community_name: test
+          informs: False
+
+      - name: configure snmp host trap-level
+        arubaoss_snmp:
+          community_name: test
+          host_ip: 10.1.1.1
+          trap_level: "{{item}}"
+        with_items:
+          - STL_ALL
+          - STL_CRITICAL
+          - STL_NOT_INFO
+          - STL_DEBUG
+          - STL_NONE
+
+      - name: configure snmp host inform retry timeout traplevel
+        arubaoss_snmp:
+          community_name: test
+          host_ip: 10.1.1.1
+          informs: True
+          inform_retries: "{{item.retry}}"
+          inform_timeout: "{{item.timeout}}"
+          trap_level: "{{item.trap}}"
+        with_items:
+          - {"retry":10,"timeout":20,"trap":"STL_CRITICAL"}
+          - {"retry":100,"timeout":200,"trap":"STL_DEBUG"}
+
+      - name: configure snmp host oobm
+        arubaoss_snmp:
+          community_name: test
+          host_ip: 10.1.1.1
+          use_oobm: "{{item}}"
+        with_items:
+          - True
+          - True
+
+      - name: delete snmp host
+        arubaoss_snmp:
+          community_name: test
+          state: delete
+          host_ip: 10.1.1.1
+
+      - name: configure snmp host
+        arubaoss_snmp:
+          community_name: test
+          host_ip: 10.1.1.1
+          state : delete
+
+
+      - name: delete snmp community
+        arubaoss_snmp:
+          community_name: test
+          state: delete
+
+      - name: delete snmp community
+        arubaoss_snmp:
+          community_name: test
+          state: delete
+
+      - name: snmp contact and location
+        arubaoss_snmp:
+          location: lab
+          contact: test_lab
+
+      - name: delete snmp location
+        arubaoss_snmp:
+          location: lab
+          state: delete
+
+      - name: delete snmp contact
+        arubaoss_snmp:
+          contact: test_lab
+          state: delete
+
+'''
+
+
+from ansible.module_utils.basic import AnsibleModule
+from ansible.module_utils.network.arubaoss.arubaoss import run_commands,get_config
+from ansible.module_utils.network.arubaoss.arubaoss import arubaoss_argument_spec
+
+
+def community(module):
+
+    params = module.params
+    url = '/snmp-server/communities'
+    check_url = url + '/' + params['community_name']
+
+    if params['state'] == 'create':
+        snmp_config = get_config(module, check_url)
+        if snmp_config:
+            url = check_url
+            method = 'PUT'
+        else:
+            method = 'POST'
+
+        data = {
+                'access_type': params['access_type'],
+                'community_name': params['community_name'],
+                'restricted': params['restricted']
+                }
+
+    else:
+        url = check_url
+        method = 'DELETE'
+        data = {}
+
+    result = run_commands(module, url, data, method, check=check_url)
+
+    return result
+
+
+def host(module):
+
+    params = module.params
+    url = '/snmp-server/hosts'
+
+    for key in ['host_ip','version']:
+        if not params[key]:
+            return {'msg': 'Missing {} in parameter list'.format(key), 'changed': False}
+
+    check_url = url + '/' + params['host_ip'] + '-' + params['community_name']
+    if params['state'] == 'create':
+
+        check_host = get_config(module, check_url)
+        if check_host:
+            method = 'PUT'
+            url = check_url
+        else:
+            method = 'POST'
+        data = {
+                'host_ip': {
+                    'octets': params['host_ip'],
+                    'version': params['version']
+                    },
+                'community': params['community_name'],
+                'trap_level': params['trap_level'],
+                'informs': params['informs'],
+                'use_oobm': params['use_oobm'],
+                }
+
+        if params['informs']:
+            data.update({
+                'informs': params['informs'],
+                'inform_timeout': params['inform_timeout'],
+                'inform_retries': params['inform_retries']
+                })
+
+    else:
+        data = {}
+        method = 'DELETE'
+        url = check_url
+
+    result = run_commands(module, url, data, method, check=check_url)
+
+    return result
+
+
+def loc_contact(module):
+
+    params = module.params
+    url = '/system'
+    data = {}
+
+    if params['state'] == 'create':
+
+        if params['location']:
+            data['location'] = params['location']
+
+        if params['contact']:
+            data['contact'] = params['contact']
+    else:
+        if params['location']:
+            data['location'] = ""
+
+        if params['contact']:
+            data['contact'] = ""
+
+
+    result = run_commands(module, url, data, 'PUT', check=url)
+
+    return result
+
+
+def run_module():
+    module_args = dict(
+        state=dict(type='str', required=False, default='create',
+            choices=['create','delete']),
+        community_name=dict(type='str', required=False),
+        access_type=dict(type='str', required=False, default='UT_OPERATOR',
+            choices=['UT_OPERATOR','UT_MANAGER']),
+        restricted=dict(type='bool', required=False, default=True),
+        host_ip=dict(type='str', required=False),
+        version=dict(type='str', required=False, default='IAV_IP_V4'),
+        trap_level=dict(type='str', required=False, default='STL_NONE',
+            choices=['STL_ALL','STL_CRITICAL','STL_NOT_INFO','STL_DEBUG',
+                'STL_NONE']),
+        informs=dict(type='bool', required=False, default=False),
+        inform_timeout=dict(type='int', required=False, default=15),
+        inform_retries=dict(type='int', required=False, default=3),
+        use_oobm=dict(type='bool', required=False, default=False),
+        location=dict(type='str', required=False),
+        contact=dict(type='str', required=False),
+    )
+
+    module_args.update(arubaoss_argument_spec)
+
+    resuult = dict(changed=False,warnings='Not Supported')
+
+    module = AnsibleModule(
+        argument_spec=module_args,
+        supports_check_mode=True
+    )
+
+    if module.check_mode:
+        module.exit_json(**result)
+
+    try:
+        if module.params['host_ip']:
+            result = host(module)
+        elif module.params['community_name']:
+            result = community(module)
+        else:
+            result = loc_contact(module)
+    except Exception as err:
+        return module.fail_json(msg=err)
+
+    module.exit_json(**result)
+
+
+def main():
+    run_module()
+
+if __name__ == '__main__':
+    main()
diff --git a/ansible/modules/network/arubaoss/arubaoss_snmp_trap.py b/ansible/modules/network/arubaoss/arubaoss_snmp_trap.py
new file mode 100644
index 0000000..fc1faa7
--- /dev/null
+++ b/ansible/modules/network/arubaoss/arubaoss_snmp_trap.py
@@ -0,0 +1,285 @@
+#!/usr/bin/python
+
+ANSIBLE_METADATA = {
+    'metadata_version': '1.1',
+    'status': ['preview'],
+    'supported_by': 'community'
+}
+
+DOCUMENTATION = '''
+---
+module: arubaoss_snmp_trap
+
+short_description: implements rest api for snmp trap configuration
+
+version_added: "2.6"
+
+description:
+    - "This implements rest api's which enable/disable snmp traps for
+       differente features on device"
+
+options:
+    arp_protect:
+        description:
+            - Traps for dynamic arp protection
+        required: false
+        default: STM_ENABLE
+        choices: STM_ENABLE, STM_DISABLE, STM_NONE
+    aut_server_fail:
+        description:
+            - Traps reporting authentication server unreachable
+        required: false
+        default: STM_ENABLE
+        choices: STM_ENABLE, STM_DISABLE, STM_NONE
+    dhcp_server:
+        description:
+            - Trpas for dhcp server
+        required: false
+        default: STM_ENABLE
+        choices: STM_ENABLE, STM_DISABLE, STM_NONE
+    dhcp_snooping:
+        description:
+            - Traps for dhcp snooping
+        required: false
+        default: STM_ENABLE
+        choices: STM_ENABLE, STM_DISABLE, STM_NONE
+    dhcpv6_snooping_out_of_resource:
+        description:
+            - Enable traps for dhcpv6 snooping out of resource
+        required: false
+        default: STM_ENABLE
+        choices: STM_ENABLE, STM_DISABLE, STM_NONE
+    dhcpv6_snooping_errant_replies:
+        description:
+            - Traps for DHCPv6 snooping errant replies
+        required: false
+        default: STM_ENABLE
+        choices: STM_ENABLE, STM_DISABLE, STM_NONE
+    dyn_ip_lockdown:
+        description:
+            - Traps for Dynamic Ip Lockdown
+        required: false
+        default: STM_ENABLE
+        choices: STM_ENABLE, STM_DISABLE, STM_NONE
+    dyn_ipv6_ld_out_of_resources:
+        description:
+            - Enable traps for Dynamic IPv6 Lockdown out of resources
+        required: false
+        default: STM_ENABLE
+        choices: STM_ENABLE, STM_DISABLE, STM_NONE
+    dyn_ipv6_ld_violations:
+        description:
+            - Enable traps for Dynamic IPv6 Lockdown violations.
+        required: false
+        default: STM_ENABLE
+        choices: STM_ENABLE, STM_DISABLE, STM_NONE
+    login_failure_mgr:
+        description:
+            - Traps for management interface login failure
+        required: false
+        default: STM_ENABLE
+        choices: STM_ENABLE, STM_DISABLE, STM_NONE
+    mac_count_notify:
+        description:
+            - Traps for MAC addresses learned on the specified ports exceeds the threshold
+        required: false
+        default: STM_ENABLE
+        choices: STM_ENABLE, STM_DISABLE, STM_NONE
+    nd_snooping_out_of_resources:
+        description:
+            - The trap for nd snooping out of resources
+        required: false
+        default: STM_ENABLE
+        choices: STM_ENABLE, STM_DISABLE, STM_NONE
+    password_change_mgr:
+        description:
+            - Traps for management interface password change
+        required: false
+        default: STM_ENABLE
+        choices: STM_ENABLE, STM_DISABLE, STM_NONE
+    port_security:
+        description:
+            - Traps for port access authentication failure
+        required: false
+        default: STM_ENABLE
+        choices: STM_ENABLE, STM_DISABLE, STM_NONE
+    startup_config_change:
+        description:
+            - Traps for changed to the startup config
+        required: false
+        default: STM_DISABLE
+        choices: STM_ENABLE, STM_DISABLE, STM_NONE
+    macsec_failure:
+        description:
+            - Enable the MACsec Connectivity Association (CA) failure trap
+        required: false
+        default: STM_ENABLE
+        choices: STM_ENABLE, STM_DISABLE, STM_NONE
+    mac_move_notify_mode:
+        description:
+            - Traps for move mac address table changes
+        required: false
+        default: STM_DISABLE
+        choices: STM_ENABLE, STM_DISABLE, STM_NONE
+    mac_notify_mode:
+        description:
+            - Traps for mac notify
+        required: false
+        default: STM_DISABLE
+        choices: STM_ENABLE, STM_DISABLE, STM_NONE
+    running_conf_change_trap:
+        description:
+            - Traps mode for running config change
+        required: false
+        default: STM_DISABLE
+        choices: STM_ENABLE, STM_DISABLE, STM_NONE
+    snmp_authentication:
+        description:
+            - Select RFC1157 (standard) or HP-ICF-SNMP (extended) traps
+        required: false
+        default: SATM_EXTENDED
+        choices: SATM_EXTENDED, SATM_STANDARD, SATM_NONE
+    mac_notify_trap_interval:
+        description:
+            - Trap interval for mac_move_notify_mode and mac_notify_mode
+        required: false
+        default: 30
+        choices: 0-120
+    running_config_trap_interval:
+        description:
+            - Traps interval for running_conf_change_trap
+        required: false
+        default: 0
+        choices: 0-120
+
+
+author:
+    - Ashish Pant (@hpe)
+'''
+
+EXAMPLES = '''
+      - name: configure snmp trap
+        arubaoss_snmp_traps:
+          mac_move_notify_mode: "{{item}}"
+        with_items:
+          - STM_ENABLE
+          - STM_DISABLE
+
+'''
+
+
+from ansible.module_utils.basic import AnsibleModule
+from ansible.module_utils.network.arubaoss.arubaoss import run_commands
+from ansible.module_utils.network.arubaoss.arubaoss import arubaoss_argument_spec
+
+
+def snmp_trap(module):
+
+    params = module.params
+    url = '/snmp-server/traps'
+
+    data = {
+            'arp_protect': params['arp_protect'],
+            'auth_server_fail': params['auth_server_fail'],
+            'dhcp_server': params['dhcp_server'],
+            'dhcp_snooping': params['dhcp_snooping'],
+            'dhcpv6_snooping_out_of_resource': params['dhcpv6_snooping_out_of_resource'],
+            'dhcpv6_snooping_errant_replies': params['dhcpv6_snooping_errant_replies'],
+            'dyn_ip_lockdown': params['dyn_ip_lockdown'],
+            'dyn_ipv6_ld_out_of_resources': params['dyn_ipv6_ld_out_of_resources'],
+            'dyn_ipv6_ld_violations': params['dyn_ipv6_ld_violations'],
+            'login_failure_mgr': params['login_failure_mgr'],
+            'mac_count_notify': params['mac_count_notify'],
+            'nd_snooping_out_of_resources': params['nd_snooping_out_of_resources'],
+            'password_change_mgr': params['password_change_mgr'],
+            'port_security': params['port_security'],
+            'startup_config_change': params['startup_config_change'],
+            'macsec_failure': params['macsec_failure'],
+            'mac_notify' : {
+                'mac_move_notify_mode': params['mac_move_notify_mode'],
+                'mac_notify_mode': params['mac_notify_mode'],
+                'trap_interval': params['mac_notify_trap_interval']
+                },
+            'running_config_changes': {
+                'running_conf_change_trap': params['running_conf_change_trap'],
+                'trap_interval': params['running_config_trap_interval']
+                },
+            'snmp_authentication': params['snmp_authentication']
+            }
+
+    result = run_commands(module, url, data, 'PUT', check=url)
+
+    return result
+
+
+def run_module():
+    module_args = dict(
+        arp_protect=dict(type='str', required=False, default='STM_ENABLE',
+            choices=['STM_ENABLE','STM_DISABLE','STM_NONE']),
+        auth_server_fail=dict(type='str', required=False, default='STM_ENABLE',
+            choices=['STM_ENABLE','STM_DISABLE','STM_NONE']),
+        dhcp_server=dict(type='str', required=False, default='STM_ENABLE',
+            choices=['STM_ENABLE','STM_DISABLE','STM_NONE']),
+        dhcp_snooping=dict(type='str', required=False, default='STM_ENABLE',
+            choices=['STM_ENABLE','STM_DISABLE','STM_NONE']),
+        dhcpv6_snooping_out_of_resource=dict(type='str', required=False, default='STM_ENABLE',
+            choices=['STM_ENABLE','STM_DISABLE','STM_NONE']),
+        dhcpv6_snooping_errant_replies=dict(type='str', required=False, default='STM_ENABLE',
+            choices=['STM_ENABLE','STM_DISABLE','STM_NONE']),
+        dyn_ip_lockdown=dict(type='str', required=False, default='STM_ENABLE',
+            choices=['STM_ENABLE','STM_DISABLE','STM_NONE']),
+        dyn_ipv6_ld_out_of_resources=dict(type='str', required=False, default='STM_ENABLE',
+            choices=['STM_ENABLE','STM_DISABLE','STM_NONE']),
+        dyn_ipv6_ld_violations=dict(type='str', required=False, default='STM_ENABLE',
+            choices=['STM_ENABLE','STM_DISABLE','STM_NONE']),
+        login_failure_mgr=dict(type='str', required=False, default='STM_ENABLE',
+            choices=['STM_ENABLE','STM_DISABLE','STM_NONE']),
+        mac_count_notify=dict(type='str', required=False, default='STM_ENABLE',
+            choices=['STM_ENABLE','STM_DISABLE','STM_NONE']),
+        nd_snooping_out_of_resources=dict(type='str', required=False, default='STM_ENABLE',
+            choices=['STM_ENABLE','STM_DISABLE','STM_NONE']),
+        password_change_mgr=dict(type='str', required=False, default='STM_ENABLE',
+            choices=['STM_ENABLE','STM_DISABLE','STM_NONE']),
+        port_security=dict(type='str', required=False, default='STM_ENABLE',
+            choices=['STM_ENABLE','STM_DISABLE','STM_NONE']),
+        startup_config_change=dict(type='str', required=False, default='STM_DISABLE',
+            choices=['STM_ENABLE','STM_DISABLE','STM_NONE']),
+        macsec_failure=dict(type='str', required=False, default='STM_ENABLE',
+            choices=['STM_ENABLE','STM_DISABLE','STM_NONE']),
+        mac_move_notify_mode=dict(type='str', required=False, default='STM_DISABLE',
+            choices=['STM_ENABLE','STM_DISABLE','STM_NONE']),
+        mac_notify_mode=dict(type='str', required=False, default='STM_DISABLE',
+            choices=['STM_ENABLE','STM_DISABLE','STM_NONE']),
+        running_conf_change_trap=dict(type='str', required=False, default='STM_ENABLE',
+            choices=['STM_ENABLE','STM_DISABLE','STM_NONE']),
+        snmp_authentication=dict(type='str', required=False, default='SATM_EXTENDED',
+            choices=['SATM_EXTENDED','SATM_STANDARD','SATM_NONE']),
+        mac_notify_trap_interval=dict(type='int', requried=False, default=30),
+        running_config_trap_interval=dict(type='int', required=False, default=0),
+    )
+
+    module_args.update(arubaoss_argument_spec)
+
+    result = dict(changed=False,warnings='Not Supported')
+
+    module = AnsibleModule(
+        argument_spec=module_args,
+        supports_check_mode=True
+    )
+
+    if module.check_mode:
+        module.exit_json(**result)
+
+    try:
+        result = snmp_trap(module)
+    except Exception as err:
+        return module.fail_json(msg=err)
+
+    module.exit_json(**result)
+
+
+def main():
+    run_module()
+
+if __name__ == '__main__':
+    main()
diff --git a/ansible/modules/network/arubaoss/arubaoss_stp.py b/ansible/modules/network/arubaoss/arubaoss_stp.py
new file mode 100644
index 0000000..efb5fa8
--- /dev/null
+++ b/ansible/modules/network/arubaoss/arubaoss_stp.py
@@ -0,0 +1,199 @@
+#!/usr/bin/python
+
+ANSIBLE_METADATA = {
+    'metadata_version': '1.1',
+    'status': ['preview'],
+    'supported_by': 'community'
+}
+
+DOCUMENTATION = '''
+---
+module: arubaoss_stp
+
+short_description: implements rest api for stp configuration
+
+version_added: "2.4"
+
+description:
+    - "This implements rest apis which can be used to configure STP"
+
+options:
+    command:
+        description: Function name calls according to configuration required
+        choices: config_spanning_tree, config_spanning_tree_port
+        required: True
+    config:
+        description: To config or unconfig the required command
+        choices: create, delete
+        required: False
+    mode:
+        description:
+        required: False
+    priority:
+        description:
+        required: False
+    port_id:
+        description: ID of the port
+        required: False
+    is_enable_admin_edge_port:
+        description: Enable/Disable admin-edge-port
+        required: False
+    is_enable_bpdu_protection:
+        description: Enable/Disable bpdu-protection.
+        required: False
+    is_enable_bpdu_filter:
+        description: Enable/Disable bpdu-filter.
+        required: False
+    is_enable_root_guard:
+        description: Enable/Disable root-guard.
+        required: False
+
+author:
+    - Sanju Sadanandan (@hpe)
+'''
+
+EXAMPLES = '''
+     - name: update spanning tree port
+       arubaoss_stp:
+         port_id: 2
+         mode:  "STM_MSTP"
+         priority: 2
+         is_enable_bpdu_protection: True
+         is_enable_bpdu_filter: True
+         is_enable_root_guard: True
+         command: config_spanning_tree_port
+'''
+
+from ansible.module_utils.basic import AnsibleModule
+from ansible.module_utils.network.arubaoss.arubaoss import run_commands
+from ansible.module_utils.network.arubaoss.arubaoss import arubaoss_argument_spec
+from ansible.module_utils.network.arubaoss.arubaoss import get_config
+
+"""
+-------
+Name: config_spanning_tree
+
+Configures Spanning Tree on device
+
+param request: module
+
+Returns
+ The switch with params configured
+-------
+"""
+def config_spanning_tree(module):
+
+    params = module.params
+    url = "/stp"
+    data  = {}
+
+    if params['config'] == "create":
+        data = {'is_enabled' : True}
+    else:
+        data = {'is_enabled' : False}
+
+    data['priority'] = params['priority']
+    data['mode'] = params['mode']
+
+    method = 'PUT'
+
+    result = run_commands(module, url, data, method, check=url)
+    return result
+
+"""
+-------
+Name: config_spanning_tree_port
+
+Configures port with stp config
+
+param request: module
+
+Returns
+ The switch with params configured
+-------
+"""
+def config_spanning_tree_port(module):
+
+    params = module.params
+    data  = {}
+
+    if params['port_id'] == "":
+        return {'msg': 'Port Id cannot be null',
+                   'changed': False, 'failed': False}
+    else:
+        data['port_id'] = params ['port_id']
+
+    data['priority'] = params ['priority']
+    data['is_enable_admin_edge_port'] = params ['is_enable_admin_edge_port']
+    data['is_enable_bpdu_protection'] = params ['is_enable_bpdu_protection']
+    data['is_enable_bpdu_filter'] = params ['is_enable_bpdu_filter']
+    data['is_enable_root_guard'] = params ['is_enable_root_guard']
+
+    url = "/stp/ports/" + str(params ['port_id'])
+
+    # Check if spanning tree is enabled
+    check_presence = get_config(module, '/stp')
+    if check_presence:
+        method = 'PUT'
+    else:
+        return {'msg': 'Cannot configure MST on port without spanning tree enabled',
+                   'changed': False, 'failed': False}
+
+    result = run_commands(module, url, data, method, check=url)
+    return result
+
+"""
+-------
+Name: run_module()
+
+The main module invoked
+
+Returns
+ Configure the switch with params sent
+-------
+"""
+def run_module():
+    module_args = dict(
+        command=dict(type='str', required=False, default='config_spanning_tree',
+               choices=['config_spanning_tree', 'config_spanning_tree_port']),
+        config=dict(type='str', required=False, default="create",
+               choices=['create', 'delete']),
+        port_id=dict(type='str', required=False, default=""),
+        priority=dict(type='int', required=False, default=8),
+        mode=dict(type='str', required=False, default="STM_MSTP",
+               choices=["STM_MSTP", "STM_RPVST"]),
+        is_enable_admin_edge_port=dict(type='bool', required=False, default=False),
+        is_enable_bpdu_protection=dict(type='bool', required=False, default=False),
+        is_enable_bpdu_filter=dict(type='bool', required=False, default=False),
+        is_enable_root_guard=dict(type='bool', required=False, default=False),
+    )
+
+    module_args.update(arubaoss_argument_spec)
+
+    result = dict(changed=False,warnings='Not Supported')
+
+    module = AnsibleModule(
+        argument_spec=module_args,
+        supports_check_mode=True
+    )
+
+    if module.check_mode:
+        module.exit_json(**result)
+
+    try:
+        if module.params['command'] == "config_spanning_tree":
+            result = config_spanning_tree(module)
+        elif module.params['command'] == "config_mstp_port":
+            result = config_mstp_port(module)
+        else:
+            result = config_spanning_tree_port(module)
+    except Exception as err:
+        return module.fail_json(msg=err)
+
+    module.exit_json(**result)
+
+def main():
+    run_module()
+
+if __name__ == '__main__':
+    main()
diff --git a/ansible/modules/network/arubaoss/arubaoss_syslog.py b/ansible/modules/network/arubaoss/arubaoss_syslog.py
new file mode 100644
index 0000000..bcb2955
--- /dev/null
+++ b/ansible/modules/network/arubaoss/arubaoss_syslog.py
@@ -0,0 +1,157 @@
+#!/usr/bin/python
+
+ANSIBLE_METADATA = {
+    'metadata_version': '1.1',
+    'status': ['preview'],
+    'supported_by': 'community'
+}
+
+DOCUMENTATION = '''
+---
+module: arubaoss_syslog
+
+short_description: implements rest api for syslog configuration
+
+version_added: "2.6"
+
+description:
+    - "This implements rest api's which configure syslog on device"
+
+options:
+    server_address:
+        description:
+            - syslog server IP address
+        required: true
+    version:
+        description:
+            - Server IP address version
+        default: IAV_IP_V4
+        choices: IAV_IP_V4, IAV_IP_V6
+        required: false
+    description:
+        description:
+            - Server description
+        required: false
+    protocol:
+        description:
+            - Type of protocol to configure
+        default: TP_UDP
+        choices: TP_TCP, TP_UDP, TP_TLS
+        required: false
+    server_port:
+        description:
+            - Server port id to be configured
+        required: false
+    state:
+        description:
+            - Create of delete configuration
+        default: create
+        choices: create,delete
+        required: false
+
+
+author:
+    - Ashish Pant (@hpe)
+'''
+
+EXAMPLES = '''
+      - name: configure syslog server
+        arubaoss_syslog:
+          server_address: 1.1.1.1
+          protocol: TP_TCP
+
+      - name: delete syslog server
+        arubaoss_syslog:
+          server_address: 1.1.1.1
+          state: delete
+
+'''
+
+from ansible.module_utils.basic import AnsibleModule
+from ansible.module_utils.network.arubaoss.arubaoss import run_commands,get_config
+from ansible.module_utils.network.arubaoss.arubaoss import arubaoss_argument_spec
+import sys
+
+def config_syslog(module):
+
+    params = module.params
+    url = '/syslog/servers'
+    check_url = url + '/' + params['server_address']
+
+    if params['state'] == 'delete':
+        result = run_commands(module, check_url, method='DELETE', check=check_url)
+        return result
+    else:
+        check_syslog = get_config(module,check_url)
+        if check_syslog:
+            method = 'PUT'
+            url = check_url
+        else:
+            method = 'POST'
+
+    data = {
+            'ip_address': {
+                'octets': params['server_address'],
+                'version': params['version']
+                },
+            'transport_protocol': params['protocol'],
+           }
+
+    protocol = params['protocol']
+    if params['server_port'] == 0:
+        if protocol == 'TP_UDP':
+            port = 514
+        elif protocol == 'TP_TCP':
+            port = 1470
+        elif protocol == 'TP_TLS':
+            port = 6514
+        data.update({'port': port})
+    else:
+        data.update({'port': params['server_port']})
+
+    if params['description']:
+        data.update({'control_description': params['description']})
+
+    result = run_commands(module, url, data, method, check=check_url)
+
+    return result
+
+
+def run_module():
+    module_args = dict(
+        server_address=dict(type='str', required=True),
+        state=dict(type='str', required=False, defualt='create',
+            choices=['create','delete']),
+        version=dict(type='str', required=False, default='IAV_IP_V4',
+            choices=['IAV_IP_V4','IAV_IP_V6']),
+        description=dict(type='str', required=False, default= ""),
+        protocol=dict(type='str', required=False, default='TP_UDP',
+            choices=['TP_UDP','TP_TCP','TP_TLS']),
+        server_port=dict(type='int', required=False, default=0),
+    )
+
+    module_args.update(arubaoss_argument_spec)
+
+    result = dict(changed=False,warnings='Not Supported')
+
+    module = AnsibleModule(
+        argument_spec=module_args,
+        supports_check_mode=True
+    )
+
+    if module.check_mode:
+        module.exit_json(**result)
+
+    try:
+        result = config_syslog(module)
+    except Exception as err:
+        return module.fail_json(msg=err)
+
+    module.exit_json(**result)
+
+
+def main():
+    run_module()
+
+if __name__ == '__main__':
+    main()
diff --git a/ansible/modules/network/arubaoss/arubaoss_system_attributes.py b/ansible/modules/network/arubaoss/arubaoss_system_attributes.py
new file mode 100644
index 0000000..8fb2e2a
--- /dev/null
+++ b/ansible/modules/network/arubaoss/arubaoss_system_attributes.py
@@ -0,0 +1,170 @@
+#!/usr/bin/python
+
+ANSIBLE_METADATA = {
+    'metadata_version': '1.1',
+    'status': ['preview'],
+    'supported_by': 'community'
+}
+
+DOCUMENTATION = '''
+---
+module: arubaoss_system_attributes
+
+short_description: implements rest api for DOT1x configuration
+
+version_added: "2.4"
+
+description:
+    - "This implements rest apis which can be used to configure DOT1x"
+
+options:
+    hostname:
+        description: The system name
+        required: False
+    location:
+        description: Location where the system is installed
+        required: False
+    contact:
+        description: Contact information for the system.
+        required: False
+    domain_name:
+        description: Regulatory domain where the system is operating on
+        required: False
+    version:
+        description: Version of ip address
+        required: False
+    device_operation_mode:
+        description: Mode in which the device is operating on
+        required: False
+    uplink_vlan_id:
+        description: Vlan via which central is connected. This is applicable
+                     only when device_operation_mode is DOM_CLOUD or DOM_CLOUD_WITH_SUPPORT.
+                     This won't be available for non Central uses case
+        required: False
+    uplink_ip:
+        description: Ip address of Vlan via which central is connected. This is
+                     applicable only when device_operation_mode is DOM_CLOUD or
+                     DOM_CLOUD_WITH_SUPPORT. This won't be available for non Central uses case
+        required: False
+    default_gateway_ip:
+        description: The global IPV4 default gateway. Input octets as 0.0.0.0 to reset.
+        required: False
+
+author:
+    - Sanju Sadanandan (@hpe)
+'''
+
+EXAMPLES = '''
+     - name: Updates the given console authorization configuration to the system
+       arubaoss_system_attributes:
+         hostname: "Test_santorini"
+         location: "Bangalore"
+         contact: "08099035734"
+         domain_name: "hpe.com"
+         version: "IAV_IP_V4"
+         device_operation_mode: "DOM_AUTONOMOUS"
+         uplink_vlan_id: "10"
+         uplink_ip: "10.100.20.30"
+         default_gateway_ip: "10.100.119.1"
+'''
+
+from ansible.module_utils.basic import AnsibleModule
+from ansible.module_utils.network.arubaoss.arubaoss import run_commands
+from ansible.module_utils.network.arubaoss.arubaoss import arubaoss_argument_spec
+
+"""
+-------
+Name: config
+
+Configures port with system_attributes config
+
+param request: module
+
+Returns
+ Configure the switch with params sent
+-------
+"""
+def config(module):
+
+    params = module.params
+    data = {}
+
+    if not params['hostname'] == "":
+        data['name'] = params['hostname']
+
+    if not params['location'] == "":
+        data['location'] = params['location']
+
+    if not params['contact'] == "":
+        data['contact'] = params['contact']
+
+    if not params['domain_name'] == "":
+        data['regulatory_domain'] = params['domain_name']
+
+    if not params['uplink_ip'] == "":
+        data['uplink_ip_address'] = {'version': params['version'], 'octets': params['uplink_ip']}
+
+    if not params['default_gateway_ip'] == "":
+        data['default_gateway'] = {'version': params['version'], 'octets': params['default_gateway_ip']}
+
+    if not params['uplink_vlan_id'] == "":
+        data['uplink_vlan_id'] = params['uplink_vlan_id']
+
+    if not params['device_operation_mode'] == "":
+        data['device_operation_mode'] = params['device_operation_mode']
+
+    url = '/system'
+    method = 'PUT'
+
+    result = run_commands(module, url, data, method, check=url)
+    return result
+"""
+-------
+Name: run_module()
+
+The main module invoked
+
+Returns
+ Configure the switch with params sent
+-------
+"""
+def run_module():
+    module_args = dict(
+        hostname=dict(type='str', required=False, default=''),
+        location=dict(type='str', required=False, default=''),
+        contact=dict(type='str', required=False, default=''),
+        version=dict(type='str', required=False, default='IAV_IP_V4',
+           choices=['IAV_IP_V4','IAV_IP_V6']),
+        domain_name=dict(type='str', required=False, default=''),
+        default_gateway=dict(type='str', required=False, default=''),
+        device_operation_mode=dict(type='str', required=False, default='DOM_AUTONOMOUS',
+           choices = ["DOM_CLOUD","DOM_CLOUD_WITH_SUPPORT","DOM_AUTONOMOUS"]),
+        uplink_vlan_id=dict(type='str', required=False, default=''),
+        uplink_ip=dict(type='str', required=False, default=''),
+        default_gateway_ip=dict(type='str', required=False, default=''),
+    )
+
+    module_args.update(arubaoss_argument_spec)
+
+    result = dict(changed=False,warnings='Not Supported')
+
+    module = AnsibleModule(
+        argument_spec=module_args,
+        supports_check_mode=True
+    )
+
+    if module.check_mode:
+        module.exit_json(**result)
+
+    try:
+        result = config(module)
+    except Exception as err:
+        return module.fail_json(msg=err)
+
+    module.exit_json(**result)
+
+def main():
+    run_module()
+
+if __name__ == '__main__':
+    main()
diff --git a/ansible/modules/network/arubaoss/arubaoss_tacas_profile.py b/ansible/modules/network/arubaoss/arubaoss_tacas_profile.py
new file mode 100644
index 0000000..97f8498
--- /dev/null
+++ b/ansible/modules/network/arubaoss/arubaoss_tacas_profile.py
@@ -0,0 +1,185 @@
+#!/usr/bin/python
+
+ANSIBLE_METADATA = {
+    'metadata_version': '1.1',
+    'status': ['preview'],
+    'supported_by': 'community'
+}
+
+DOCUMENTATION = '''
+---
+module: arubaoss_tacacs_profile
+
+short_description: implements rest api for Tacacs configuration
+
+version_added: "2.4"
+
+description:
+    - "This implements rest apis which can be used to configure TACACS Server"
+
+options:
+    command:
+        description: Function name calls according to configuration required
+        choices: config_tacacs_profile, config_tacacs_server
+        required: True
+    config:
+        description: To config or unconfig the required command
+        choices: create, delete
+        required: False
+    dead_time
+        description: Dead time for unavailable TACACS+ servers
+        required: False
+    time_out
+        description: TACACS server response timeout
+        required: False
+    global_auth_key
+        description: Authentication key
+        required: False
+    server_ip
+        description: TACACS Server IP Address
+        required: False
+    auth_key
+        description: Authentication key
+        required: False
+    is_oobm
+        description: Use oobm interface to connect the server
+        required: False
+author:
+    - Sanju Sadanandan (@hpe)
+'''
+
+EXAMPLES = '''
+     - name: Updates the given tacacs profile configuration to the system
+       arubaoss_tacacs_profile:
+         command: config_tacacs_profile
+         dead_time: 10
+         time_out: 3
+         global_auth_key: ""
+'''
+
+from ansible.module_utils.basic import AnsibleModule
+from ansible.module_utils.network.arubaoss.arubaoss import run_commands
+from ansible.module_utils.network.arubaoss.arubaoss import arubaoss_argument_spec
+from ansible.module_utils.network.arubaoss.arubaoss import get_config
+
+"""
+-------
+Name: config_tacacs_profile
+
+Configures port with tacacs profile config
+
+param request: module
+
+Returns
+ Configure the switch with params sent
+-------
+"""
+def config_tacacs_profile(module):
+
+    params = module.params
+
+    data = {}
+    data['dead_time'] = params ['dead_time']
+    data['time_out'] = params ['time_out']
+    data['global_auth_key'] = params ['global_auth_key']
+
+    url = '/tacacs_profile'
+    method = 'PUT'
+
+    result = run_commands(module, url, data, method, check=url)
+    return result
+"""
+-------
+Name: config_tacacs_server
+
+Configures port with tacas server
+
+param request: module
+
+Returns
+ Configure the switch with params sent
+-------
+"""
+def config_tacacs_server(module):
+
+    params = module.params
+
+    data = {}
+    if params['ip_address'] == "" or params['version'] == "":
+        return {'msg': "IP Address or version cannot be null",
+                'changed': False, 'failed': False}
+    else:
+        data ["server_ip"] = {"version": params['version'], "octets": params['ip_address']}
+
+    data ["auth_key"] = params ['auth_key']
+    data ["is_oobm"] = params ['is_oobm']
+
+    create_url = '/tacacs_profile/server'
+    check_url = '/tacacs_profile/server/' + str(params['ip_address'])
+
+    if params['config'] == "create":
+       check_presence = get_config(module, '/tacacs_profile/server/' + str(params['ip_address']))
+       if not check_presence:
+           url = create_url
+           method = 'POST'
+       else:
+           url = check_url
+           method = 'PUT'
+    else:
+       url = check_url
+       method = 'DELETE'
+
+    result = run_commands(module, url, data, method,check=check_url)
+    return result
+"""
+-------
+Name: run_module()
+
+The main module invoked
+
+Returns
+ Configure the switch with params sent
+-------
+"""
+def run_module():
+    module_args = dict(
+        command=dict(type='str', required=False, default="config_tacacs_profile",
+            choices=["config_tacacs_profile", "config_tacacs_server"]),
+        config=dict(type='str', required=False, default="create",
+            choices=["create", "delete"]),
+        dead_time=dict(type='int', required=False, default='10'),
+        time_out=dict(type='int', required=False, default='0'),
+        global_auth_key=dict(type='str', required=False,default=""),
+        auth_key=dict(type='str', required=False,default=""),
+        ip_address=dict(type='str', required=False,default=""),
+        version=dict(type='str', required=False,default=""),
+        is_oobm=dict(type='bool', required=False,default=False),
+    )
+
+    module_args.update(arubaoss_argument_spec)
+
+    result = dict(changed=False,warnings='Not Supported')
+
+    module = AnsibleModule(
+        argument_spec=module_args,
+        supports_check_mode=True
+    )
+
+    if module.check_mode:
+        module.exit_json(**result)
+
+    try:
+        if module.params['command'] == "config_tacacs_profile":
+            result = config_tacacs_profile(module)
+        else:
+            result = config_tacacs_server(module)
+    except Exception as err:
+        return module.fail_json(msg=err)
+
+    module.exit_json(**result)
+
+def main():
+    run_module()
+
+if __name__ == '__main__':
+    main()
diff --git a/ansible/modules/network/arubaoss/arubaoss_traffic_class.py b/ansible/modules/network/arubaoss/arubaoss_traffic_class.py
new file mode 100644
index 0000000..b61c2b3
--- /dev/null
+++ b/ansible/modules/network/arubaoss/arubaoss_traffic_class.py
@@ -0,0 +1,405 @@
+#!/usr/bin/python
+
+ANSIBLE_METADATA = {
+    'metadata_version': '1.1',
+    'status': ['preview'],
+    'supported_by': 'community'
+}
+
+DOCUMENTATION = '''
+---
+module: arubaoss_interfaces
+
+short_description: implements rest api for port configuration
+
+version_added: "2.4"
+
+description:
+    - "This implements rest apiis whcih can be used to configure ports"
+
+options:
+    class_name:
+        description:
+            - Traffic class name
+        required: true
+    class_type:
+        description:
+            - Traffic class type
+        default: QCT_IP_V4
+        choices: QCT_IP_V4, QCT_IP_V6
+        required: true
+    dscp_value:
+        description:
+            - dscp value to be applied
+        choices: 0-64
+        required: false
+    entry_type:
+        description:
+            - Type of action to take.
+        choices: QTCET_MATCH, QTCET_IGNORE
+        required: false
+    protocol_type:
+        description:
+            - Protocol type for traffic filter.
+        required: false
+        choices: 'PT_GRE','PT_ESP','PT_AH','PT_OSPF','PT_PIM','PT_VRRP',
+                 'PT_ICMP','PTIGMP','PT_IP','PT_SCTP','PT_TCP','PT_UDP'
+    icmp_type:
+        description:
+            - Applies to icmp type matching this field. Only PT_ICMP
+              protocol_type support icmp_code
+        required: false
+    icmp_code:
+        description:
+            - Applies to icmp code matching this field. Only PT_ICMP
+              protocol_type support icmp_code
+        required: false
+    igmp_type:
+        description:
+            - Applies to igmp type matching this field. Only PT_IGMP
+              protocol_type support igmp_type
+        required: false
+    match_bit:
+        description:
+            - The set of tcp match bits . Only PT_TCP  protocol_type
+              support match_bit
+        required: false
+    source_port:
+        description:
+            - Applies to source port matching this filter. Only PT_SCTP,
+              PT_TCP and PT_UDP Protocol types support source_port
+        required: false
+    destination_port:
+        description:
+            - Applies to destination port matching this filter. Only
+              PT_SCTP,PT_TCP and PT_UDP Protocol types support destination_port
+        required: false
+    source_ip_address:
+        description:
+            - Applies to source IP Address/Subnet matching this extended traffic filter
+        required: false
+    source_ip_mask:
+        description:
+            - Net mask source_ip_address
+        required: false
+    destination_ip_address:
+        description:
+            - Applies to destination IP Address/Subnet matching this extended traffic filter
+        required: false
+    device_type:
+        description:
+            - Applies to device type matching this extended traffic filter
+        required: false
+    application_type:
+        description:
+            - Applies to application matching this extended traffic filter
+        required: fasle
+    precedence:
+        description:
+            - IP precedence flag
+        required: false
+        choices: 0, 1, 2, 3, 4, 5, 6, 7
+    tos:
+        description:
+            - Tos value
+        required: false
+        choices: 0, 2, 4, 8
+    sequece_no:
+        description:
+            - Sequence number for the traffic class configured
+        required: false
+
+
+author:
+    - Ashish Pant (@hpe)
+'''
+
+EXAMPLES = '''
+      - name: create traffic class
+        arubaoss_traffic_class:
+          class_name: my_class
+
+      - name: add match criteria
+        arubaoss_traffic_class:
+          class_name: my_class
+          icmp_code: 1
+          icmp_type: 1
+          source_ip_address: 0.0.0.0
+          source_ip_mask: 255.255.255.255
+          destination_ip_address: 0.0.0.0
+          destination_ip_mask: 255.255.255.255
+          protocol_type: "PT_ICMP"
+          entry_type: QTCET_MATCH
+
+      - name: add udp traffic ignore rule
+        arubaoss_traffic_class:
+          class_name: my_class
+          source_ip_address: 0.0.0.0
+          source_ip_mask: 255.255.255.255
+          destination_ip_address: 0.0.0.0
+          destination_ip_mask: 255.255.255.255
+          protocol_type: "PT_UDP"
+          entry_type: QTCET_IGNORE
+          destination_port: {"port_not_equal": 0,"port_range_start": 443,"port_range_end": 443}
+
+      - name: delete traffic class
+        arubaoss_traffic_class:
+          class_name: my_class
+          state: delete
+
+'''
+
+from ansible.module_utils.basic import AnsibleModule
+from ansible.module_utils.network.arubaoss.arubaoss import run_commands,get_config
+from ansible.module_utils.network.arubaoss.arubaoss import arubaoss_argument_spec
+from ansible.module_utils._text import to_text
+
+
+def traffic_class(module):
+
+    params = module.params
+    url = '/qos/traffic-classes'
+    class_id = params['class_name'] + '~' +  params['class_type']
+
+    check_url = url + '/' + class_id
+
+    if params['state'] == 'create':
+        data = {
+            'class_name': params['class_name'],
+            'class_type': params['class_type']
+           }
+        method = 'POST'
+
+    elif params['state'] == 'delete':
+
+        qos_url = '/qos/policies'
+        qos_config = get_config(module, qos_url)
+
+        if qos_config:
+            check_config = module.from_json(to_text(qos_config))
+            port_url = '/qos/ports-policies'
+            port_config = get_config(module, port_url)
+            if port_config:
+                port_config = module.from_json(to_text(port_config))
+
+            # Check if qos is applied to any vlan
+            vlan_url = '/qos/vlans-policies'
+            vlan_config = get_config(module, vlan_url)
+            if vlan_config:
+                vlan_config = module.from_json(to_text(vlan_config))
+
+            for qos in check_config['qos_policy_element']:
+            # Check if qos is applied to any port
+                class_url = qos_url + '/'+ qos['id'] + '/policy-actions'
+                class_config = get_config(module, class_url)
+                check_class = module.from_json(to_text(class_config))
+                if check_class:
+                    for qos_action in check_class['qos_policy_action_element']:
+                        if qos_action['traffic_class_id'] == class_id:
+                            for port in port_config['qos_port_policy_element']:
+                                if qos['id'] == port['policy_id']:
+                                    return {'msg': 'Class {} is active in qos policy {} for port {}.\
+                                            Remove qos policy first'.format(class_id,qos['id'],port['port_id']),
+                                            'changed':False}
+
+                            for vlan in vlan_config['qos_vlan_policy_element']:
+                                if qos['id'] == vlan['policy_id']:
+                                    return {'msg': 'Class {} is active in qos policy {} for vlan {}.\
+                                            Remove qos policy first'.format(class_id,qos['id'],vlan['vlan_id']),
+                                            'changed':False}
+
+        url = check_url
+        data = {}
+        method = 'DELETE'
+
+    result = run_commands(module, url, data, method,check=check_url)
+
+    return result
+
+
+def traffic_class_match(module):
+
+    params = module.params
+
+    class_id = params['class_name'] + '~' +  params['class_type']
+
+    url = '/qos/traffic-classes/' + class_id
+
+    # Create traffic class if not present
+    traffic_class(module)
+
+    if params['class_type'] == 'QCT_IP_V4':
+        version = 'IAV_IP_V4'
+    else:
+        version = 'IAV_IP_V6'
+
+
+    match_url = url + '/matches'
+    if params['sequence_no'] > 0:
+        url = match_url + '/' + str(params['sequence_no'])
+        method = 'PUT'
+    else:
+        url = match_url
+        method = 'POST'
+
+
+
+    if params['state'] == 'create':
+
+        protocol = params.get('protocol_type')
+        if not protocol:
+            return {'msg': 'protocol_type is required','changed':False}
+
+        data = {
+                'traffic_class_id': class_id,
+                'entry_type': params['entry_type'],
+                }
+
+        if params['dscp_value']:
+            data['dscp_value'] = params['dscp_value']
+
+        data.update({
+            "traffic_match": {
+                "protocol_type": params['protocol_type'],
+                "source_ip_address": {
+                    "version": version,
+                    "octets": params['source_ip_address']
+                    },
+                "source_ip_mask": {
+                    "version": version,
+                    "octets": params['source_ip_mask']
+                    },
+                "destination_ip_address": {
+                    "version": version,
+                    "octets": params['destination_ip_address']
+                    },
+                "destination_ip_mask": {
+                    "version": version,
+                    "octets": params['destination_ip_mask']
+                    }
+                }
+            })
+
+        if protocol == 'PT_ICMP':
+            if params['icmp_type'] > -1:
+                data['traffic_match']['icmp_type'] = params['icmp_type']
+            if params['icmp_code'] > -1:
+                data['traffic_match']['icmp_code'] = params['icmp_code']
+
+        if protocol == 'PT_IGMP':
+            if params['igmp_type']:
+                data['traffic_match']['igmp_type'] = params['igmp_type']
+
+        if protocol == 'PT_TCP':
+            if params['match_bit']:
+                data['traffic_match']['match_bit'] = params['match_bit']
+
+        if protocol in ('PT_SCTP','PT_TCP','PT_UDP'):
+            if params['source_port']:
+                data['traffic_match']['source_port'] = params['source_port']
+
+            if params['destination_port']:
+                data['traffic_match']['destination_port'] = params['destination_port']
+
+        if params['precedence']:
+            data['traffic_match']['precedence'] = params['precedence']
+
+        if params['tos']:
+            data['traffic_match']['tos'] = params['tos']
+
+
+        qos_config = get_config(module, match_url)
+        if qos_config:
+            print("HERE")
+            check_config = module.from_json(to_text(qos_config))
+            print("CHECK",check_config)
+            for config in check_config['qos_class_match_element']:
+                if config['traffic_match']['protocol_type'] == 'PT_TCP':
+                    config['traffic_match'].pop('is_connection_established')
+
+                if params['entry_type'] == config['entry_type'] and \
+                    config['traffic_match'] == data['traffic_match']:
+                        ret = {'changed':False}
+                        ret.update(config)
+                        return ret
+
+
+        result = run_commands(module, url, data, method)
+        message = result.get('body') or None
+        if message:
+            if 'Duplicate' in message or 'Configuration Failed' in message :
+                result = {'changed': False}
+                result['failed'] = False
+                result['message'] = message
+                result.update(data)
+                return result
+
+    else:
+        result = run_commands(module, url, {}, 'DELETE', check=url)
+
+    return result
+
+
+def run_module():
+    module_args = dict(
+        class_name=dict(type='str', required=True),
+        class_type=dict(type='str', required=False,default='QCT_IP_V4',
+            choices=['QCT_IP_V4','QCT_IP_V6']),
+        dscp_value=dict(type='int', reqquired=False, choices=[i for i in range(0,64)]),
+        state=dict(type='str', required=False, default='create',
+            choices=['create','delete']),
+        sequence_no=dict(type='int', required=False, default=-1),
+        entry_type=dict(type='str', required=False, choices=['QTCET_MATCH','QTCET_IGNORE']),
+        protocol_type=dict(type='str', required=False, choices=['PT_GRE','PT_ESP',
+            'PT_AH','PT_OSPF','PT_PIM','PT_VRRP','PT_ICMP','PTIGMP','PT_IP','PT_SCTP',
+            'PT_TCP','PT_UDP']),
+        icmp_type=dict(type='int', required=False, defualt=-1),
+        icmp_code=dict(type='int', required=False, default=-1),
+        igmp_type=dict(type='str', required=False, choices=['IT_HOST_QUERY',
+            'IT_HOST_REPORT','IT_DVMRP','IT_PIM','IT_TRACE','IT_V2_HOST_REPORT',
+            'IT_V2_HOST_LEAVE','IT_MTRACE_REPLY','IT_MTRACE_REQUEST','IT_V3_HOST_REPORT',
+            'IT_MROUTER_ADVERTISEMENT','IT_MROUTER_SOLICITATION','IT_MROUTER_TERMINATION']),
+        match_bit=dict(type='list', required=False, choices=['MB_ACK','MB_FIN',
+            'MB_RST','MB_SYN']),
+        source_port=dict(type='dict', required=False),
+        destination_port=dict(type='dict', required=False),
+        source_ip_address=dict(type='str', required=False),
+        source_ip_mask=dict(type='str', required=False),
+        destination_ip_address=dict(type='str', required=False),
+        destination_ip_mask=dict(type='str', required=False),
+        device_type=dict(type='str', required=False,),
+        application_type=dict(type='str', required=False),
+        precedence=dict(type='int', required=False, choices=[0,1,2,3,4,5,6,7]),
+        tos=dict(type='int', required=False,choices=[0,2,4,8]),
+    )
+
+    module_args.update(arubaoss_argument_spec)
+
+    result = dict(changed=False,warnings='Not Supported')
+
+    module = AnsibleModule(
+        argument_spec=module_args,
+        supports_check_mode=True
+    )
+
+    if module.check_mode:
+        module.exit_json(**result)
+
+    try:
+
+        if module.params['entry_type']:
+            result = traffic_class_match(module)
+        else:
+            result = traffic_class(module)
+
+    except Exception as err:
+        return module.fail_json(msg=err)
+
+    module.exit_json(**result)
+
+
+def main():
+    run_module()
+
+if __name__ == '__main__':
+    main()
diff --git a/ansible/modules/network/arubaoss/arubaoss_user.py b/ansible/modules/network/arubaoss/arubaoss_user.py
new file mode 100644
index 0000000..7afb286
--- /dev/null
+++ b/ansible/modules/network/arubaoss/arubaoss_user.py
@@ -0,0 +1,167 @@
+#!/usr/bin/python
+
+ANSIBLE_METADATA = {
+    'metadata_version': '1.1',
+    'status': ['preview'],
+    'supported_by': 'community'
+}
+
+DOCUMENTATION = '''
+---
+module: arubaoss_user
+
+short_description: Implements Ansible module for configuring and
+                   managing user on device.
+
+version_added: "2.6"
+
+description:
+    - "This implement rest api's which can be use to manage and configure
+       user on the device. Can configure only operator role via REST"
+
+options:
+    user_name:
+        description:
+            - user_name that needs to be configured.
+        required: true
+    user_type:
+        description:
+            - Type of user being configured.
+        required: true
+        default: UT_OPERATOR
+    user_password:
+        description:
+            - user password in plain text or sha1
+        required: true
+    password_type:
+        description:
+            - type of password being conifgured
+        required: true
+        choices: PET_PLAIN_TEXT, PET_SHA1
+    state:
+        description:
+            - Enable or disable
+        choices: create, delete
+        default: create
+        required: false
+
+author:
+    - Ashish Pant (@hpe)
+'''
+
+EXAMPLES = '''
+      - name: configure user
+        arubaoss_user:
+          user_name:  test_user
+          user_password: test_user
+          user_type: UT_OPERATOR
+          password_type: PET_PLAIN_TEXT
+
+      - name: delete user
+        arubaoss_user:
+          user_name:  test_user
+          user_password: test_user
+          user_type: UT_OPERATOR
+          password_type: PET_PLAIN_TEXT
+          state: delete
+
+      - name: configure user sha1
+        arubaoss_user:
+          user_name: test_user
+          user_password: F0347CE3A03A3BA71F596438A2B80DD21C9AF71B
+          user_type: UT_OPERATOR
+          password_type: PET_SHA1
+
+'''
+
+from ansible.module_utils.basic import AnsibleModule
+from ansible.module_utils.network.arubaoss.arubaoss import run_commands,get_config
+from ansible.module_utils.network.arubaoss.arubaoss import arubaoss_argument_spec
+from ansible.module_utils._text import to_text
+
+
+def config_user(module):
+
+    params = module.params
+    url = '/management-user'
+
+    if params['state'] == 'create':
+        for key in ['user_password','password_type','user_name']:
+            if key not in params:
+                return {'msg': '{} is mandatory to create user'.format(key),
+                        'changed': False, 'failed':True}
+
+    data = {
+            'type': params['user_type'],
+            'name': params['user_name'],
+            'password': params['user_password'],
+            'password_type': params['password_type']
+            }
+
+    method = 'POST'
+    delete_url = url + '/' + params['user_type']
+    get_user = get_config(module, delete_url)
+    if get_user:
+        if params['state'] == 'delete':
+            method = 'DELETE'
+        else:
+            method = 'PUT'
+        url = delete_url
+
+    if params['state'] == 'create':
+        inc_url = '/system/include-credentials'
+        check_presence = get_config(module, inc_url)
+        check_presence = module.from_json(to_text(check_presence))
+
+        if check_presence:
+            inc_url = '/system/include-credentials'
+            if check_presence['include_credentials_in_response'] == 'ICS_DISABLED' and\
+                    params['password_type'] == 'PET_SHA1':
+                        inc_data = {'include_credentials_in_response': 'ICS_ENABLED'}
+                        run_commands(module, inc_url, inc_data, 'PUT',wait_after_send=5)
+
+            elif check_presence['include_credentials_in_response'] != 'ICS_DISABLED' and\
+                    params['password_type'] == 'PET_PLAIN_TEXT':
+                        inc_data = {'include_credentials_in_response':'ICS_DISABLED'}
+                        run_commands(module, inc_url, inc_data, 'PUT',wait_after_send=5)
+
+    result = run_commands(module, url, data, method)
+    return result
+
+
+def run_module():
+    module_args = dict(
+        user_name=dict(type='str', required=True, no_log=True),
+        user_type=dict(type='str', required=True, default='UT_OPERATOR'),
+        user_password=dict(type='str', required=False, no_log=True),
+        password_type=dict(type='str', required=False, choices=['PET_PLAIN_TEXT',
+            'PET_SHA1']),
+        state=dict(type='str', required=False, default='create',
+            choices=['create','delete']),
+    )
+
+    module_args.update(arubaoss_argument_spec)
+
+    result = dict(changed=False,warnings='Not Supported')
+
+    module = AnsibleModule(
+        argument_spec=module_args,
+        supports_check_mode=True
+    )
+
+    if module.check_mode:
+        module.exit_json(**result)
+
+    try:
+        result = config_user(module)
+    except Exception as err:
+        return module.fail_json(msg=err)
+
+    module.exit_json(**result)
+
+
+def main():
+    run_module()
+
+if __name__ == '__main__':
+    main()
diff --git a/ansible/modules/network/arubaoss/arubaoss_vlan.py b/ansible/modules/network/arubaoss/arubaoss_vlan.py
new file mode 100644
index 0000000..5b77f6e
--- /dev/null
+++ b/ansible/modules/network/arubaoss/arubaoss_vlan.py
@@ -0,0 +1,539 @@
+#!/usr/bin/python
+
+ANSIBLE_METADATA = {
+    'metadata_version': '1.1',
+    'status': ['preview'],
+    'supported_by': 'community'
+}
+
+DOCUMENTATION = '''
+---
+module: arubaoss_vlan
+
+short_description: implements rest api for vlan configuration
+
+version_added: "2.4"
+
+description:
+    - "This implements rest apis which can be used to configure vlan"
+
+options:
+    command:
+        description: Name of sub module, according to the configuration required.
+        choices: config_vlan, config_vlan_port,
+                config_vlan_ipaddress, config_vlan_dhcpHelperAddress
+        required: True
+    config:
+        description: To config or unconfig the required command
+        choices: create, delete
+        required: False
+    vlan_id:
+        description: vlan id to be configured
+        required: true
+    name:
+        description: Name of the VLAN. While creating a Vlan If name is given
+        as empty string, default value (VLANx, where x is the vlan_id) will be
+        configured. Empty string will not be accepted while modifying a Vlan
+        required: false
+    status:
+        description: the status of the VLAN
+        choices: VS_PORT_BASED, VS_PROTOCOL_BASED, VS_DYNAMIC
+        required: false
+    vlantype:
+        description: The type of VLAN, default being VT_STATIC
+        choices: VT_STATIC, VT_STATIC_SVLAN, VT_GVRP
+        required: false
+    is_jumbo_enabled:
+        description:  Whether Jumbo is enabled
+        required: false
+    is_voice_enabled:
+        description:  Whether Voice is enabled
+        required: false
+    is_dsnoop_enabled:
+        description:  Whether DSNOOP is enabled
+        required: false
+    is_dhcp_server_enabled:
+        description:  Whether DHCP server is enabled
+        required: false
+    is_management_vlan:
+        description:  Whether vlan is a management vlan or not
+        required: false
+    ip_address_mode:
+        description: IP Address Mode to be configured on vlan
+        choices: IAAM_DISABLED, IAAM_STATIC, IAAM_DHCP
+        required: False
+    vlan_ip_address:
+        description: IP Address to be configured on vlan
+        required: False
+    vlan_ip_mask:
+        description: IP Mask for the IP Address configured
+        required: False
+    version:
+        description: Version of IP Address
+        choices: IAV_IP_V4. (V6 is not supported via REST)
+        required: False
+    helper_addresses:
+        description: DHCP helper address for the corresponding VLAN id
+        required: False
+    port_id:
+        description: Port ID to be configured on the vlan
+        required: False
+    port_mode:
+        description: Port modes to be configured
+        choices: POM_UNTAGGED, POM_TAGGED_STATIC, POM_FORBIDDEN
+        required: False
+    qos_policy:
+        description: Qos policy to be added to vlan
+        required: False
+    acl_id:
+        description: Acl policy to be added to vlan
+        required: false
+    acl_type:
+        description: Type of acl policy
+        default: AT_STANDARD_IPV4
+        choices: AT_STANDARD_IPV4, AT_EXTENDED_IPV4, AT_CONNECTION_RATE_FILTER
+        required: false
+    acl_direction:
+        description: Direction is which acl to be applied
+        choices: AD_INBOUND, AD_OUTPUND, AD_CRF
+        required: false
+
+
+author:
+    - Sanju Sadanandan (@hpe)
+'''
+
+EXAMPLES = '''
+     - name: configure vlan
+       arubaoss_vlan:
+         vlan_id: 300
+         name: "vlan300"
+         status: "VS_PORT_BASED"
+         vlantype: "VT_STATIC"
+         is_jumbo_enabled: false
+         is_voice_enabled: false
+         is_dsnoop_enabled: false
+         is_dhcp_server_enabled: false
+         is_management_vlan: false
+         config: "create"
+         command: config_vlan
+'''
+
+from ansible.module_utils.basic import AnsibleModule
+from ansible.module_utils.network.arubaoss.arubaoss import run_commands
+from ansible.module_utils.network.arubaoss.arubaoss import get_config
+from ansible.module_utils.network.arubaoss.arubaoss import arubaoss_argument_spec
+from ansible.module_utils._text import to_text
+import json
+
+
+"""
+-------
+Name: config_vlan_ipaddress
+
+Configures IP Address on the VLAN
+
+param request: module
+
+Returns
+ Configure the switch with params sent
+-------
+"""
+def config_vlan_ipaddress(module):
+
+    params = module.params
+    data = {}
+
+    # Parameters
+    if params['vlan_id'] == "":
+        return {'msg': "vlan_id cannot be null",
+                'changed': False, 'failed': False}
+    else:
+        data = {'vlan_id': params['vlan_id']}
+
+    if params['version'] == "" or params['vlan_ip_address'] == "":
+        return {'msg': "IP Address or version cannot be null",
+                'changed': False, 'failed': False}
+    else:
+        data['ip_address'] = {'version': params['version'], 'octets': params['vlan_ip_address']}
+
+    if params['version'] == "" or params['vlan_ip_mask'] == "":
+        return {'msg': "Subnet mask or version cannot be null",
+                'changed': False, 'failed': False}
+    else:
+        data['ip_mask'] = {'version': params['version'], 'octets': params['vlan_ip_mask']}
+
+    data['ip_address_mode'] = params['ip_address_mode']
+
+    # URLs
+    url = "/vlans/" + str(params['vlan_id']) + "/ipaddresses"
+    check_url = url + params['ip_address_mode'] + "-" +  params['vlan_ip_address']
+
+    # Check if the passed vlan is configured
+    check_presence_vlan = get_config(module, url)
+    if not check_presence_vlan:
+        return {'msg': 'Cannot configure IP Address without Vlan configured',
+                'changed': False, 'failed': False}
+    else:
+        if params ['config'] == "create":
+            check_presence = get_config(module, url)
+            newdata = json.loads(check_presence)
+
+            # Check if IP already configured
+            if newdata['collection_result']['total_elements_count'] == 1:
+                if newdata['ip_address_subnet_element'][0]['ip_address']['octets'] == params['vlan_ip_address']:
+                    return {'msg': 'The ip address is already present on switch',
+                      'changed': False, 'failed': False}
+
+                else:
+                    method = 'DELETE'
+                    result = run_commands(module, url, data, method)
+
+            # Create the ip address on vlan
+            method = 'POST'
+            result = run_commands(module, url, data, method)
+
+        elif params ['config'] == "delete":
+            method = 'DELETE'
+            result = run_commands(module, check_url, data, method, check=check_url)
+
+        else:
+            return {'msg': 'Valid config options are : create and delete',
+                'changed': False, 'failed': False}
+
+    return result
+
+"""
+-------
+Name: config_vlan_port
+
+Configures Port on VLAN
+
+param request: module
+
+Returns
+ Configure the switch with params sent
+-------
+"""
+def config_vlan_port(module):
+
+    params = module.params
+    # Parameters
+    if params['vlan_id'] == "":
+        return {'msg': "vlan_id cannot be null",
+                'changed': False, 'failed': False}
+    else:
+        data = {'vlan_id': params['vlan_id']}
+
+    if params['port_id'] == "":
+        return {'msg': "port_id cannot be null",
+                'changed': False, 'failed': False}
+    else:
+        data['port_id'] = params['port_id']
+
+    data['port_mode'] = params['port_mode']
+
+    del_url = "/vlans-ports/" + str(params['vlan_id']) + "-" + str(params['port_id'])
+
+    # Check if the passed vlan is configured
+    check_presence = get_config(module, "/vlans/"+ str(params['vlan_id']))
+    if not check_presence:
+        return {'msg': 'Cannot configure ports without Vlan configured',
+                'changed': False, 'failed': False}
+    else:
+        if params['config'] == "create":
+            check_presence = get_config(module, del_url)
+            if not check_presence:
+                url = '/vlans-ports'
+                method = 'POST'
+            else:
+                url = "/vlans-ports/" + str(params['vlan_id']) + "-" + str(params['port_id'])
+                method = 'PUT'
+        elif params['config'] == "delete":
+            url = "/vlans-ports/" + str(params['vlan_id']) + "-" + str(params['port_id'])
+            method = 'DELETE'
+        else:
+            return {'msg': 'Valid config options are : create and delete',
+                'changed': False, 'failed': False}
+
+        result = run_commands(module, url, data, method, check=del_url)
+        return result
+
+# Add dhcp helper address to vlan
+"""
+-------
+Name: config_vlan_dhcpHelperAddress
+
+Configure DHCP Helper Address on VLAN
+
+param request: module
+
+Returns
+ Configure the switch with params sent
+-------
+"""
+def config_vlan_dhcpHelperAddress(module):
+
+    params = module.params
+
+    # Parameters
+    if params['vlan_id'] == "":
+        return {'msg': "vlan_id cannot be null",
+                'changed': False, 'failed': False}
+    else:
+        data = {'vlan_id': params['vlan_id']}
+
+    if params['helper_addresses'] == "":
+        return {'msg': "DHCP Helper IP Addr cannot be null",
+                'changed': False, 'failed': False}
+    else:
+        data['dhcp_helper_address'] = {'version': params['version'], 'octets': params['helper_addresses']}
+
+    url = "/vlans/dhcp-relay"
+    del_url = url + '/' + str(params['vlan_id']) + '-' + params['helper_addresses']
+
+    # Check if the passed vlan is configured
+    check_presence = get_config(module, "/vlans/"+ str(params['vlan_id']))
+    if not check_presence:
+        return {'msg': 'Cannot configure Helper Address without Vlan configured',
+                'changed': False, 'failed': False}
+
+    else:
+        if params ['config'] == "create":
+            method = 'POST'
+        else:
+            url = del_url
+            method = 'DELETE'
+
+        result = run_commands(module, url, data, method, check=del_url)
+        return result
+
+"""
+-------
+Name: config_vlan
+
+Configures VLAN with the id and name given
+
+param request: module
+
+Returns
+ Configure the switch with params sent
+-------
+"""
+def config_vlan(module):
+
+    params = module.params
+
+    # Parameters
+    if params['vlan_id'] == "":
+        return {'msg': "vlan_id cannot be null",
+                'changed': False, 'failed': False}
+    else:
+        data = {'vlan_id': params['vlan_id']}
+
+    if params['name'] == "":
+        return {'msg': "vlan name cannot be null",
+                'changed': False, 'failed': False}
+    else:
+       data['name'] = params['name']
+
+    data['status'] = params['status']
+    data['type'] = params['vlantype']
+    data['is_jumbo_enabled'] = params['is_jumbo_enabled']
+    data['is_voice_enabled'] = params['is_voice_enabled']
+    data['is_dsnoop_enabled'] = params['is_dsnoop_enabled']
+    data['is_dhcp_server_enabled'] = params['is_dhcp_server_enabled']
+    data['is_management_vlan'] = params['is_management_vlan']
+
+    config_url = "/vlans/" + str(params['vlan_id'])
+
+    if params ['config'] == "create":
+        check_presence = get_config(module, "/vlans/params['vlan_id']")
+        if not check_presence:
+            url = "/vlans"
+            method = 'POST'
+        else:
+            url = "/vlans/" + str(params['vlan_id'])
+            method = 'PUT'
+    else:
+        url = config_url
+        method = 'DELETE'
+
+    result = run_commands(module, url, data, method, check=config_url)
+    return result
+
+
+def config_qos(module):
+
+    params = module.params
+
+    url = '/qos/vlans-policies'
+    # if no vlan exists
+    config_vlan(module)
+
+    # check qos policy is present
+    qos_check = '/qos/policies/' + params['qos_policy'] + '~' + 'QPT_QOS'
+    if not get_config(module, qos_check):
+        return {'msg': 'Configure QoS policy first. {} does not exist'.\
+                format(params['qos_policy']),'changed':False}
+
+
+    if params['config'] == 'create':
+        policy_id = params['qos_policy'] + '~' + 'QPT_QOS'
+        vlan_config = get_config(module, url)
+        if vlan_config:
+            check_config = module.from_json(to_text(vlan_config))
+            for vlans in check_config['qos_vlan_policy_element']:
+                if vlans['vlan_id'] == params['vlan_id'] and\
+                   vlans['policy_id'] == policy_id:
+                       ret = {'changed':False}
+                       ret.update(vlans)
+                       return ret
+
+
+        data = {
+                'vlan_id': params['vlan_id'],
+                'policy_id': policy_id
+                }
+        result = run_commands(module, url,data, 'POST')
+
+    else:
+        url =  url + '/' + str(params['vlan_id']) + '-' + params['qos_policy'] + '~' + 'QPT_QOS'
+        check_url = url + '/stats'
+
+        result = run_commands(module, url, {}, 'DELETE', check=check_url)
+
+    return result
+
+
+def config_acl(module):
+
+    params = module.params
+
+    if params.get('acl_direction') is None:
+        return {'msg': 'Missing parameter: acl_direction','changed':False}
+
+    # Check if acl is present
+    url = "/vlans-access-groups"
+    acl_type = params['acl_type']
+    direction = params['acl_direction']
+    data = {'vlan_id': params['vlan_id'],
+            'acl_id': params['acl_id'] + "~" + acl_type,
+            'direction': direction}
+
+    check_acl = '/acls/' + params['acl_id'] + "~" + acl_type
+    if not get_config(module,check_acl):
+        return {'msg': 'Configure ACL first. {} does not exist'.\
+                                format(params['acl_id']),'changed':False}
+
+    delete_url = url + '/' + str(params['vlan_id']) + '-' + params['acl_id'] + "~" + acl_type\
+            + '-' +  direction
+
+    config_present = False
+    current_acl = get_config(module,url)
+    if current_acl:
+        check_config = module.from_json(to_text(current_acl))
+
+        for ele in check_config['acl_vlan_policy_element']:
+            if ele['uri'] == delete_url:
+                config_present = ele
+
+
+    if params['config'] == 'create':
+        if config_present:
+            ret = {'changed': False}
+            ret.update(ele)
+            return ret
+        else:
+            result = run_commands(module, url, data, method='POST')
+    else:
+        if config_present:
+            result = run_commands(module, delete_url, method='DELETE')
+        else:
+            return {'changed': False,'failed': False, 'msg': 'Not present'}
+
+    return result
+
+
+"""
+-------
+Name: run_module()
+
+The main module invoked
+
+Returns
+ Configure the switch with params sent
+-------
+"""
+def run_module():
+    module_args = dict(
+        command=dict(type='str', default='config_vlan',
+               choices=['config_vlan', 'config_vlan_port',
+                'config_vlan_ipaddress', 'config_vlan_dhcpHelperAddress',
+                'config_vlan_qos','config_vlan_acl']),
+        config=dict(type='str', required=False, default= "create",
+               choices=["create","delete"]),
+        vlan_id=dict(type='int', required=True),
+        name=dict(type='str', required=False, default=""),
+        ip_address_mode=dict(type='str', required=False, default="IAAM_STATIC",
+           choices = ['IAAM_DISABLED', 'IAAM_STATIC', 'IAAM_DHCP']),
+        status=dict(type='str', required=False, default="VS_PORT_BASED",
+           choices = ["VS_PORT_BASED", "VS_PROTOCOL_BASED", "VS_DYNAMIC"]),
+        vlantype=dict(type='str', required=False, default="VT_STATIC",
+           choices = ["VT_STATIC", "VT_STATIC_SVLAN", "VT_GVRP"]),
+        is_jumbo_enabled=dict(type='bool', required=False, default=False),
+        is_voice_enabled=dict(type='bool', required=False, default=False),
+        is_dsnoop_enabled=dict(type='bool', required=False, default=False),
+        is_dhcp_server_enabled=dict(type='bool', required=False, default=False),
+        is_management_vlan=dict(type='bool', required=False, default=False),
+        vlan_ip_address=dict(type='str', required=False, default=""),
+        vlan_ip_mask=dict(type='str', required=False, default=""),
+        version=dict(type='str', required=False, default= 'IAV_IP_V4',
+                         choices=['IAV_IP_V4','IAV_IP_V6']),
+        helper_addresses=dict(type='str', required=False, default=""),
+        port_id=dict(type='str', required=False, default=""),
+        port_mode=dict(type='str', required=False, default="POM_UNTAGGED",
+           choices=['POM_UNTAGGED','POM_TAGGED_STATIC','POM_FORBIDDEN']),
+        qos_policy=dict(type='str', required=False),
+        acl_id=dict(type='str', required=False),
+        acl_type=dict(type='str', required=False, default='AT_STANDARD_IPV4',
+            choices=['AT_STANDARD_IPV4','AT_EXTENDED_IPV4','AT_CONNECTION_RATE_FILTER']),
+        acl_direction=dict(type='str', required=False, choices=['AD_INBOUND',
+            'AD_OUTBOUND','AD_CRF']),
+    )
+
+    module_args.update(arubaoss_argument_spec)
+
+    result = dict(changed=False,warnings='Not Supported')
+
+    module = AnsibleModule(
+        argument_spec=module_args,
+        supports_check_mode=True
+    )
+
+    if module.check_mode:
+        module.exit_json(**result)
+
+    try:
+        if module.params['command'] == "config_vlan":
+            result = config_vlan(module)
+        elif module.params['command'] == "config_vlan_dhcpHelperAddress":
+            result = config_vlan_dhcpHelperAddress(module)
+        elif module.params['command'] == "config_vlan_port":
+            result = config_vlan_port(module)
+        elif module.params['command'] == 'config_vlan_qos':
+            result = config_qos(module)
+        elif module.params['command'] == 'config_vlan_acl':
+            result = config_acl(module)
+        else:
+            result = config_vlan_ipaddress(module)
+    except Exception as err:
+        return module.fail_json(msg=err)
+
+    module.exit_json(**result)
+
+def main():
+    run_module()
+
+if __name__ == '__main__':
+    main()
diff --git a/ansible/plugins/action/arubaoss.py b/ansible/plugins/action/arubaoss.py
new file mode 100644
index 0000000..8ffd56f
--- /dev/null
+++ b/ansible/plugins/action/arubaoss.py
@@ -0,0 +1,100 @@
+#
+# (c) 2018 Red Hat Inc.
+#
+# This file is part of Ansible
+#
+# Ansible is free software: you can redistribute it and/or modify
+# it under the terms of the GNU General Public License as published by
+# the Free Software Foundation, either version 3 of the License, or
+# (at your option) any later version.
+#
+# Ansible is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+# GNU General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.
+#
+from __future__ import (absolute_import, division, print_function)
+__metaclass__ = type
+
+
+from ansible import constants as C
+from ansible.plugins.action.normal import ActionModule as _ActionModule
+from ansible.module_utils.network.arubaoss.arubaoss import arubaoss_provider_spec
+from ansible.module_utils.network.common.utils import load_provider
+
+try:
+    from __main__ import display
+except ImportError:
+    from ansible.utils.display import Display
+    display = Display()
+
+
+class ActionModule(_ActionModule):
+
+    def run(self, tmp=None, task_vars=None):
+        del tmp  # tmp no longer has any effect
+
+        socket_path = None
+
+        if self._play_context.connection == 'local':
+            provider = load_provider(arubaoss_provider_spec, self._task.args)
+            transport = provider['transport'] or 'aossapi'
+
+            display.vvvv('connection transport is %s for %s' % (transport, self._play_context.remote_addr))
+            if not provider.get('api_version') is None:
+                api = provider.get('api_version')
+                if api not in ['v1.0','v2.0','v2.1','v2.2','v3.0','v3.1','v4.0']:
+                    provider['api_version'] = None
+                    display.vvvv('%s is not valid api version. using aossapi v5.0 instead' % api)
+                else:
+                    display.vvvv('%s is not latest version (v5.0), arubaoss module may not work as intended' % api)
+
+
+            if transport == 'cli':
+                return dict(
+                        failed=True,
+                        msg='invalid connection specified, expected connection=local, '
+                        'got %s' % self._play_context.connection)
+            else:
+                self._task.args['provider'] = ActionModule.aossapi_implementation(provider, self._play_context)
+        else:
+            return dict(
+                failed=True,
+                msg='invalid connection specified, expected connection=local, '
+                    'got %s' % self._play_context.connection
+            )
+
+        result = super(ActionModule, self).run(task_vars=task_vars)
+        return result
+
+    @staticmethod
+    def aossapi_implementation(provider, play_context):
+        provider['transport'] = 'aossapi'
+        if provider.get('host') is None:
+            provider['host'] = play_context.remote_addr
+
+        if provider.get('port') is None:
+            if provider.get('use_ssl'):
+                provider['port'] = 443
+            else:
+                provider['port'] = 80
+
+        if provider.get('timeout') is None:
+            provider['timeout'] = C.PERSISTENT_COMMAND_TIMEOUT
+
+        if provider.get('username') is None:
+            provider['username'] = play_context.connection_user
+
+        if provider.get('password') is None:
+            provider['password'] = play_context.password
+
+        if provider.get('use_ssl') is None:
+            provider['use_ssl'] = False
+
+        if provider.get('validate_certs') is None:
+            provider['validate_certs'] = True
+
+        return provider
